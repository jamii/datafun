\documentclass[nomarginums]{rntz}
%\usepackage[b5]{rntzgeometry}
\usepackage[phone]{fantasy}
%\usepackage[baskerville,newmath]{rntzfont}
\usepackage[pt]{rntzfont}
\usepackage{anyfontsize}
\usepackage[spacing=true,stretch=10]{microtype}
\frenchspacing

\usepackage{amssymb,amsmath,amsthm} % \square etc.
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage[b]{esvect}              % \vv for wide vector arrows
\usepackage{nccmath}                % fix align* (etc.) spacing

%% Commands
\newcommand\todo[1]{{\color{Rhodamine}#1}}

\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\cat\textbf
\newcommand\strong\textbf
\newcommand\CP{\cat{ChangePoset}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{\ensuremath{\mathbold{0}}}
\newcommand\termO{\ensuremath{\mathbold{1}}}
\newcommand\initE{\mathop{\text{\textexclamdown}}}
\newcommand\termI{\mathop{!}}

\newcommand\G\Gamma
\newcommand\D\Delta
\newcommand\x\times
\newcommand\dee\delta
\newcommand\tuple[1]{\left({#1}\right)}
\newcommand\triv{\star}
\newcommand\injc{\mathrm{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\zero{\ensuremath{\mathbold{0}}}

\newcommand\iso{\texorpdfstring{\ensuremath{\square}}{iso}}
\newcommand\isof[1]{\iso {#1}}
\newcommand\fname[1]{\textit{#1}}
\newcommand\id{\fname{id}}
\newcommand\dummy{\fname{dummy}}

%% TODO: look at other latex arrows
\newcommand\validarrow{{\to}}
\newcommand\longvalidarrow{{\longrightarrow}}
\newcommand\valid[1]{\mathrel{\overset{#1}{\validarrow}}}
\newcommand\longvalid[1]{\mathrel{\overset{#1}{\longvalidarrow}}}
\newcommand\vals[1]{#1^v} % other options: _v, _o, _\iota
\newcommand\valfn{\vals{-}}
\newcommand\chgs[1]{\D{#1}}

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
\newcommand\Krof[1]{\left[{#1}\right]}
\renewcommand\fork\Fork
\renewcommand\krof\Krof

\renewcommand\vals{\mathcal{V}}
\renewcommand\valfn\vals

\newcommand\funct[1]{\vals{#1}}
\newcommand\deriv[1]{#1'}

\newcommand\bindsp{~\,}
\newcommand\fa[1]{\forall #1.\bindsp}
\newcommand\ex[1]{\exists #1.\bindsp}
%% \renewcommand\ex[1]{(\exists #1)\bindsp}
%% \renewcommand\fa[1]{(\forall #1)\bindsp}


\title{Change Semantics for Semi\naive{} Datafun}
\author{Michael Arntzenius}
\date{5 November 2018}

\begin{document}

\maketitle

\begin{abstract}
  We define the category \CP{} of posets equipped with \emph{increasing
    changes}, whose morphisms are monotone maps equipped with \emph{derivatives}
  taking input changes to output changes. We give a semantics for Datafun in
  \CP.
\end{abstract}

\todo{TODO: should I be using posets or preorders?}


\section{Notation and conventions}

$\initE_A : \initO \to A$ is the unique map out of an initial object; $\termI_A
: A \to \initO$ is the unique map into a terminal object.

\todo{TODO: Explain $\iso : \Poset \to \Poset$.}


\section{The category \CP}

\newcommand\pto\rightharpoonup
\newcommand\upd\oplus

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \upd_A)$, where
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.
\item $\chgs A \in \Poset$ is the poset of changes.
\item $(\upd) : \vals A \x \chgs A \pto \vals A$ is a \strong{partial} map
  taking a value and a change to an updated value. If $x \upd dx$ is defined, we
  say $dx$ is a \emph{valid} change to $x$.

  $x \valid{dx} y$ denotes that $x \upd dx$ is defined and equal to $y$.
  Otherwise, propositions involving $\upd$ should be understood to hold only
  when it is defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other
  conditions one might sensibly impose here, most notably, that $x \upd dx$ is
  monotone in $dx$. I have omitted this because I have not needed it, but the
  lack of an obvious ``correct'' set of conditions bothers me.}

\begin{align*}
  x \le y &~\implies \ex{dx} x \valid{dx} y
  & \text{complete for increases}\\
  x \le y &\impliedby~ \ex{dx} x \valid{dx} y
  & \text{sound for increases}
\end{align*}

\noindent
A morphism $f \in \CP(A, B)$ is a value map $\funct f \in \Poset(\vals A, \vals
B)$ eq\-uip\-ped with a derivative $\deriv f \in \Poset(\isof{\vals A} \x \chgs
A, \chgs B)$ such that:

\[ x \valid{dx} y \implies \funct f\,x \longvalid{\deriv f(x,dx)} \funct f\,y\]

\noindent Or, equivalently:
\[ \funct f(x \upd dx) = \funct f\,x \upd \deriv f(x, dx) \]

\noindent
Two morphisms are equal iff they have equal value maps and their derivatives'
behavior coincides on \emph{valid} changes. In other words, we \strong{quotient}
equality of derivatives as follows:

\[ (\fa{x \valid{dx} y} \deriv f(x,dx) = \deriv g(x,dx))
\implies \deriv f = \deriv g \]

\noindent
Composition of derivatives follows the chain rule:

\begin{align*}
  %% \funct\id\, x &= x &
  %% \funct{(f \circ g)}\, x &= \funct f (\funct g\,x)\\
  \funct\id &= \id & \funct{(f \circ g)} &= \funct f \circ \funct g\\
  \deriv\id(x,dx) &= dx
  & \deriv{(f \circ g)} (x,dx) &= \deriv f (g \;x,\, \deriv g(x,dx))
\end{align*}

\noindent The only interesting case of associativity is the one involving the
chain rule:
\begin{align*}
  \deriv{(f \circ (g \circ h))} (x,dx)
  &= \deriv f((g \circ h) \;x,\ \deriv{(g \circ h)}(x,dx))\\
  &= \deriv f (g(h \;x),\ \deriv g(h \;x,\ \deriv h(x,dx)))\\
  &= \deriv{(f \circ g)} (h \;x,\ \deriv h(x,dx))\\
  &= \deriv{((f \circ g) \circ h)} (x,dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we can
recover zero-change and composition operators $\zero$, $(\cdot)$ such that $x
\upd \zero_x = x$ and $x \upd (dx \cdot dy) = (x \upd dx) \upd dy$. These
do not necessarily satisfy the identity and associativity laws of a category,
but can be useful nonetheless. \todo{TODO: talk about non-constructivity and why
  it won't be a problem. maybe should go in ``strategy'' section at the top?}


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

There is a straightforward forgetful functor $\valfn : \CP \to \Poset$ taking
objects $A$ to $\vals{A}$ and morphisms $f$ to $\funct f$. The structures we
will build in \CP{} all \emph{refine} the corresponding structures in \Poset{},
meaning they commute with $\valfn$. For example, for cartesian products,
$\vals{(A \x B)} = \vals{A} \x \vals{B}$ and $\funct{\fork{f,g}} = \fork{\funct
  f, \funct g}$. For brevity's sake, we omit the ``value components'' of our
constructions when they can be derived from this fact.


\subsection{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value- and change-poset structure is inherited from \Poset{}, as are the
  value components of the universal, projection, and injection maps (see
  \S\ref{sec:refines}), while the projection and injection's derivatives operate
  pointwise on changes:

  \begin{align*}
    \vals{\left(\prod_{i \in I} A_i\right)} &= \prod_{i \in I} \vals A_i &
    \vals{\left(\sum_{i \in I} A_i\right)} &= \sum_{i \in I} \vals A_i
    \\[1em]
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\[.5em]
    \funct{\Fork{\vv f}} &= \Fork{\vv{\funct f}} &
    \funct{\Krof{\vv{f}}} &= \Krof{\vv{\funct f}}
    \\
    \funct\pi_i &= \pi_i & \funct \injc_i &= \injc_i
    \\
    \deriv\pi_i(x,dx) &= \pi_i\;dx & \deriv\injc_i(x,dx) &= \inj i dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (dx_i)_i &= (x_i \upd dx_i)_i &
    \inj i x \upd \inj i dx &= \inj i (x \upd dx)
  \end{align*}

  We calculate $\deriv{\fork{\vv f}}$ from its universal property. Imagine $g$
  such that $\deriv f_i = (\pi_i \circ g)'$ for $i \in I$. Then:

  \begin{align*}
    \deriv f_i(x,dx) &= \deriv{(\pi_i \circ g)} (x,dx)\\
    &= \deriv\pi_i(\funct g\,x,\, \deriv g(x,dx))\\
    &= \pi_i (\deriv g(x,dx))
  \end{align*}

  \noindent
  So by the universal property of products in \Poset{}, we have $\deriv g =
  \fork{\vv{\deriv f}}$. Thus $\deriv{\fork{\vv f}} = \fork{\vv{\deriv f}}$.

  Now let's try calculating $\deriv{\krof{\vv f}}$ from its universal property.
  Imagine $g$ such that $\deriv f_i = \deriv{(g \circ \injc_i)}$. Then:

  \begin{align*}
    \deriv f_i(x,dx) &= \deriv{(g \circ \injc_i)}(x,dx)\\
    &= \deriv g(\funct\injc_i(x),\, \deriv\injc_i(x,dx))\\
    &= \deriv g(\inj i x,\, \inj i dx)
  \end{align*}

  This defines $g'(\inj i x,\, \inj j dx)$ when $i = j$. What about $i \ne j$?
  Here we appeal to our quotient: derivatives are equal iff they agree on
  \emph{valid} changes. By construction, all valid changes to $\inj i x$ are of
  the form $\inj i dx$. So it \strong{does not matter} what $\deriv{\krof{\vv
      f}}(\inj i x, \inj j dx)$ does for $i \ne j$, so long as it is defined.
  One satisfactory definition is:

  \begin{equation*}
    \deriv{\Krof{\vv f}}(\inj i x,\, \inj j dx) = 
    \begin{cases}
      \deriv f_i(x,dx) & \text{if}~ i=j\\
      \fname{magic}(x) & \text{otherwise}
    \end{cases}
  \end{equation*}

  \noindent\todo{TODO}

  \pagebreak
  We show this by constructing initial and terminal objects and binary sums and
  products. In each case, both the underlying and the change posets come from
  the corresponding structure in \Poset{}:

  %% \begin{align*}
  %%   \vals \termO = \chgs \termO &= \termO \in \Poset &
  %%   \vals \initO = \chgs \initO &= \initO \in \Poset\\
  %%   \triv \upd \triv &= \triv
  %%   \\
  %%   \vals{(A \x B)} &= \vals A \x \vals B &
  %%   \vals{(A + B)} &= \vals A + \vals B
  %%   \\
  %%   \chgs{(A \x B)} &= \chgs A \x \chgs B &
  %%   \chgs{(A + B)} &= \chgs A + \chgs B \\
  %%   (a,b) \upd (da,db) &= (a \upd da, b \upd db) &
  %%   \inj i x \upd \inj i dx &= \inj i (x \upd dx)
  %% \end{align*}

  \begin{align*}
    \vals \initO = \chgs \initO &= \initO \in \Poset &
    \vals \termO = \chgs \termO &= \termO \in \Poset \\
    \vals{(A \x B)} &= \vals A \x \vals B &
    \vals{(A + B)} &= \vals A + \vals B \\
    \chgs{(A \x B)} &= \chgs A \x \chgs B &
    \chgs{(A + B)} &= \chgs A + \chgs B
  \end{align*}

  \noindent The update maps are given by:

  \begin{align*}
    \triv \upd \triv &= \triv\\
    (a,b) \upd (da,db) &= (a \upd da, b \upd db)\\
    \inj i x \upd \inj i dx &= \inj i (x \upd dx)
  \end{align*}

  \noindent Here, $\triv$ is the single inhabitant of $\termO \in \Poset$. We
  give no cases for $\initO$ because it is empty. Note that $(\inj i x \upd \inj
  j dx)$ is undefined for $i \ne j$.

  The ``value components'' of the morphisms $!$, \textexclamdown, $\pi_i$,
  $\injc_i$, $\fork{f, g}$, and $[f,g]$ are inherited from \Poset{} along
  $(\vals{-})$ (see \S\ref{sec:refines}). The derivatives of $!$, \textexclamdown,
  $\pi_i$, and $\injc_i$ simply operate pointwise on their second argument:

  \begin{align*}
    {\deriv{!}}(x,dx) &= {\funct{!}}\,dx &
    \deriv{\text{\textexclamdown}}(x,dx) &= \funct{\text{\textexclamdown}}\,dx\\
    \deriv\pi_i(x,dx) &= \funct{\pi_i}\,dx &
    \deriv\injc_i(x,dx) &= \funct{\injc_i}\,dx
  \end{align*}

  \noindent
  Note that $!$ and {\textexclamdown} inherit their universal properties from
  \Poset{}.

  We can calculate $\deriv{\fork{f_1,f_2}}$ from its universal property.
  Consider some $g$ such that $\deriv f_i = \deriv{(\pi_i \circ g)}$ for $i \in
  \{1,2\}$. Then:

  \begin{align*}
    \deriv f_i(x,dx)
    &= \deriv{(\pi_i \circ g)}(x,dx)\\
    &= \deriv\pi_i (\funct g\,x,\, \deriv g(x,dx))\\
    &= \funct\pi_i(\deriv g(x,dx))
  \end{align*}

  \noindent
  So by the universal property of products in \Poset{}, we have $g' =
  \fork{\deriv f_1, \deriv f_2}$. Thus $\deriv{\fork{f_1,f_2}} = \fork{\deriv
    f_1, \deriv f_2}$.

  Finally, let's attempt to calculate $\deriv{[f_1,f_2]}$ from its universal
  property. Consider some $g$ such that $\deriv f_i = \deriv{(g \circ
    \injc_i)}$. Then:

  \begin{align*}
    \deriv f_i(x,dx)
    &= \deriv{(g \circ \injc_i)}(x,dx)\\
    &= \deriv g (\funct\injc_i \,x,\, \deriv\injc_i \,(x,dx))\\
    &= \deriv g (\inj i x,\, \inj i dx)
  \end{align*}

  \noindent
  This defines $g'(\inj i x,\, \inj j dx)$ when $i = j$. What about $i \ne j$?
  Here we appeal to our quotient: derivatives are equal iff they agree on
  \emph{valid} changes. By construction of the validity relation for sums, all
  valid changes to $\inj i x$ are of the form $\inj i dx$. So it \strong{does
    not matter} what $\deriv{[f_1,f_2]}(\inj i x, \inj j dx)$ does for $i \ne
  j$, so long as it is defined. One satisfactory definition is:

  \begin{equation*}
    \deriv{\Krof{f_1,f_2}} (\inj{i} x,\, \inj{j} dx)
    = \begin{cases}
      \deriv f_i(x,dx) & \text{if}~ i=j\\
      \fname{magic}(x) & \text{otherwise}
    \end{cases}
  \end{equation*}

  \noindent
  Here $\fname{magic} : \vals A \to \chgs A$ is given by the axiom of choice as
  follows. Fix $x : \vals A$. By reflexivity $x \le x$, so by soundness,
  $\exists dx : \chgs A$ (indeed, one such that $x \valid{dx} x$, but this is
  irrelevant here). Let \fname{magic} be a choice function that picks such a
  $dx$.

  I omit the proofs that the derivatives are monotone in their second argument.
\end{proof}

\noindent
NB. \fname{magic} is effectively dead code: necessary to define $\deriv{[f,g]}$,
but irrelevant to its behavior. We will exploit this later to avoid needing the
axiom of choice in the context of Datafun.


\subsection{Exponential objects}

\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\df{d\kern-0.1em f\kern-.1em} % fucking kerning.

The change poset of the exponential object $\expO A B \in \CP$ consists of
monotone maps $\df, dg \in \expO{\isof{\vals A}}{\expO{\chgs A}{\chgs B}}$,
partially ordered pointwise by their effect on valid changes and quotiented to
satisfy antisymmetry:

\begin{equation*}
  \df \le dg : \chgs{(\expO A B)}
  \iff \fa{x \valid{dx} y} \df \;x \;dx \le dg \;x \;dx 
\end{equation*}

\noindent
The validity relation is:

\begin{equation*}
  f \valid{\df} g : \expO A B
  \iff \fa{x \valid{dx} y} f\;x \longvalid{df \;x \;dx} g\;y
\end{equation*}

\noindent
This is sound \& complete for increases: \todo{TODO}
\begin{align*}
  f \le g : \vals{(\expO A B)}
  &\iff f \le g : \expO{\vals A}{\vals B}\\
  &\iff \fa{x \le y} f\;x \le g\;y\\
  &\iff \fa{x,y} (\ex{dx} x \valid{dx} y)
  \implies \ex{dx} f\;x \valid{dx} g\;y\\
  &\iff \todo{???}\\
  &\iff \ex{\df} f \valid{\df} g
\end{align*}

\newcommand\fn\lambda
\todo{TODO: define \fname{eval}, compute $\fn$ from its universal property}


\subsection{The lifted \iso{} comonad}

\subsection{Semilattice objects}

\subsection{Fixed points}

\end{document}
