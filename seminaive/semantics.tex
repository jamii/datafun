%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=19cm,width=36.65625em,width=38em,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=158mm,width=373pt,]{narrow}
\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\geometry{bottom=36pt}\pagestyle{empty}

%\documentclass{rntz}\usepackage{fantasy}\geometry{textwidth=330pt,}
%\documentclass[nomarginums]{rntz}\usepackage[tablet]{fantasy}\geometry{textwidth=330pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
%% FIXME: get rid of esvect
%\usepackage[f]{esvect}              % \vv for wide vector arrows
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
%\usepackage[skip=.5\baselineskip,labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.1}{rntzfont} % a4/b5, width=38em/373pt
%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4 width=36.66em
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6
%\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}

%% \usepackage[default,scale=.96]{lato}
%% \usepackage[sfdefault,scaled=0.9]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.022}\edef\zeu@Scale{1.077}\makeatother
%% %\usepackage[italic,basic,defaultmathsizes]{mathastext}
%% \linespread{1.054}%\linespread{1.0735}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}


%% ===== Commands =====
\newcommand\todo[1]{{\color{ACMRed}#1}}
\newcommand\XXX{\todo{\text{XXX}}}

\newcommand\isocolor{\color{ForestGreen}} % ACMBlue is used in links
\newcommand\commentcolor{\color{ACMPurple}}
%\renewcommand\isocolor{}

\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\cat\textbf
\ifdefined\strong\else\newcommand\strong\textbf\fi
\newcommand\CP{\cat{\texorpdfstring{$\boldsymbol\Delta$Poset}{DeltaPoset}}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{0}
\newcommand\termO{1}
%% \newcommand\initO{\ensuremath{\mathbold{0}}}
%% \newcommand\termO{\ensuremath{\mathbold{1}}}
\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\initE{\mathord{\text{\textexclamdown}}}
\newcommand\termI{\mathord{!}}

\ifdefined\G\renewcommand\G\Gamma\else\newcommand\G\Gamma\fi
\newcommand\D\Delta
\newcommand\x\times
\newcommand\pto\rightharpoonup
\newcommand\fn\lambda
\newcommand\dee\delta
\newcommand\injc{\text{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\zero{\ensuremath{\mathbold{0}}}
\newcommand\bnfor{~~|~~}
\newcommand\bnfeq\Coloneqq
\newcommand\N{\mathbb{N}}
\newcommand\tuple[1]{\langle{#1}\rangle}

% Space for function application. Between \; and \:.
\newcommand\<{\mskip 4mu plus 4mu minus 1mu}
%\renewcommand\<\;
\newcommand\da{\mathvar{da}}
\newcommand\db{\mathvar{db}}
\newcommand\dx{\mathvar{dx}}
\newcommand\dy{\mathvar{dy}}
\newcommand\df{\mathvar{df}}
%\renewcommand\df{d\kern-.1em f\kern-.1em} % fucking kerning.
\newcommand\dg{\mathvar{dg}}

\newcommand\iso{{\texorpdfstring{\ensuremath{\square}}{iso}}}
\newcommand\isof{\iso}
\newcommand\blackiso{{\texorpdfstring{\ensuremath{\blacksquare}}{black-box}}}
\newcommand\blackisof{\blackiso}
\newcommand\fname\text
\newcommand\id{\fname{id}}
\newcommand\dummy{\fname{dummy}}
\newcommand\extract{{\color{Red}\fname{extract}}}

\newcommand\valfn{\ensuremath{\mathbb{U}}}
%\renewcommand\valfn{\ensuremath{\mathcal{U}}}
\newcommand\vals{\valfn}
\newcommand\chgs[1]{\D{#1}}
\newcommand\deriv[1]{\ensuremath{#1'}}
\newcommand\upd{\mathbin{\oplus}}
\newcommand\updfn{\ensuremath{{\upd}}}

%% \renewcommand\vals[1]{{#1}^v}
%% \renewcommand\valfn{\ensuremath{\vals{-}}}

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
\newcommand\bigkrof[1]{\bigl[{#1}\bigr]}
%\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
%\newcommand\Krof[1]{\left[{#1}\right]}

\newcommand\quantifierspace{~\,}
\newcommand\fa[1]{\forall #1.\quantifierspace}
\newcommand\ex[1]{\exists #1.\quantifierspace}
\newcommand\fnspace{\;}
\newcommand\fnof[1]{\fn{#1}.\fnspace}

\newcommand\kwname\textbf
\newcommand\tset[1]{\{{#1}\}}
\newcommand\tbool{{\boldsymbol 2}}
\newcommand\efor[1]{\kwname{for}\:({#1})\fnspace}
%\renewcommand\efor[1]{\bigvee(#1)\;}
\newcommand\ewhen[1]{\kwname{when}\:({#1})\fnspace}
\newcommand\ecase[1]{\kwname{case} \;{#1}\; \kwname{of}\;}
\newcommand\caseto\shortrightarrow
\newcommand\eset[1]{\{{#1}\}}
\newcommand\etrue{\mathrm{true}}
\newcommand\efalse{\mathrm{false}}
\newcommand\eif[2]{\kwname{if}\;{#1}\;\kwname{then}\;{#2}\;\kwname{else}\;}
\newcommand\ebox[1]{[{#1}]}
\newcommand\elet[1]{\kwname{let}\;#1\;\kwname{in}\;}
\newcommand\efix{\kwname{fix}\<}
\newcommand\eboxd[1]{\ebox{\isocolor #1}}
\newcommand\esetd[1]{\eset{\isocolor #1}}
\newcommand\eford[2]{\efor{{\isocolor #1} \in #2}}
\newcommand\eifd[2]{\eif{\isocolor #1}{#2}}
\newcommand\pwild{\underline{\phantom{a}}}
\newcommand\etuple[1]{\langle{#1}\rangle}
\newcommand\splitsum{\kwname{split}\<}

\newcommand\subst[2]{{#1}\,\{{#2}\}}
\newcommand\substd[2]{\subst{#1}{\isocolor #2}}
\newcommand\substo\coloneqq

\newcommand\den[1]{\ensuremath{\left\llbracket{#1}\right\rrbracket}}
\newcommand\bigden[1]{\ensuremath{\bigl\llbracket{#1}\bigr\rrbracket}}
\newcommand\homto\Rightarrow
\newcommand\then{\mathbin{;}}
%\renewcommand\then{\,{;}\,}
\renewcommand\then\cdot
\newcommand\catC{\ensuremath{\mathcal{C}}}
\newcommand\down{\ensuremath{F}}
\newcommand\disco{\ensuremath{W}}
\newcommand\downof[1]{\down #1}
\newcommand\discof[1]{\ensuremath{\disco #1}}
\newcommand\morph\mathit
\newcommand\idmorph{\morph{id}}
\newcommand\idfunctor{\morph{Id}}

%% \renewcommand\idmorph{1}
%% \renewcommand\idfunctor\idmorph


%% Option A
% \leadsto, \rightsquigarrow, \Rightarrow
\newcommand\validarrow\to
\newcommand\valid[1]{\mathrel{\overset{#1}{\validarrow}}}
\newcommand\longvalid[1]{\mathrel{\xrightarrow{#1}}}
\newcommand\vld[3]{{#2 \valid{#1} #3}}
\newcommand\longvld[3]{{#2 \longvalid{#1} #3}}


%% %% Option B
%% \renewcommand\validarrow\leadsto
%% \newcommand\longvalidarrow\validarrow
%% \renewcommand\longvld[3]{{#2 \mathrel{\overset{#1}{\longvalidarrow}} #3}}


%% %% Option C
%% \renewcommand\vld[3]{{#2 \xrsquigarrow{#1} #3}}
%% \renewcommand\longvld[3]{{#2 \xrsquigarrow{#1} #3}}

%% %% Adapted from https://tex.stackexchange.com/questions/233676/leadsto-with-text
%% \usepackage{tikz}
%% \usetikzlibrary{decorations.pathmorphing,shapes}

%% \usepackage{tikz-cd}
%% \usetikzlibrary{decorations.pathmorphing}
%% \newcommand\xrsquigarrow[1]{%
%%     \mathrel{%
%%         \begin{tikzpicture}[%
%%             baseline={(current bounding box.south)}
%%             ]
%%         \node[%
%%             ,inner sep=.44ex
%%             ,align=center
%%             ] (tmp) {$\scriptstyle #1$};
%%         \path[%
%%             ,draw,<-
%%             ,decorate,decoration={%
%%                 ,zigzag
%%                 ,amplitude=0.7pt
%%                 ,segment length=1.2mm,pre length=3.5pt
%%                 }
%%             ]
%%         (tmp.south east) -- (tmp.south west);
%%         \end{tikzpicture}
%%         }
%%     }


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}

\maketitle

%\noindent abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (a \emph{Datafun model}; \cref{sec:datafun-models}). We
then define the category \CP{} of posets equipped with increasing changes, whose
morphisms are monotone maps equipped with \emph{derivatives} taking input
changes to output changes (\cref{sec:changeposets}). We construct two Datafun
models in \CP{}, an \emph{incremental} (\cref{sec:incremental}) and a
\emph{semi\naive} (\cref{sec:seminaive}), from which we read off our program
transformations. By construction, the incremental semantics extends the one in
\Poset{}. To prove the semi\naive{} transform correct, we construct a
type-indexed family of natural isomorphisms relating the incremental and
semi\naive{} semantics.

%% TODO: rewrite to match above strategy and add section links


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\initE_A : \initO \to A$ is the unique map out of an initial object;\\
  $\termI_A : A \to \termO$ is the unique map into a terminal object.

\item $A \homto B$ denotes the exponential $B^A$ in a category with
  exponentials.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$. So in
  particular, $\fork{} = \termI$ and $\krof{} = \initE$.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:
  \[\setlength\arraycolsep{.33em}
  \begin{array}{rcl}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{array}\]
\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. However, with a little care, we can interpret Datafun terms into
any bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$.

\item A \emph{``downset''} functor \(\down : \catC \to \catC\) equipped with
  maps
  \begin{align*}
    \morph{strong}_{A,B} &: A \x \downof{B} \to \downof{(A \x B)}\\
    \morph{singleton}_A &: A \to \downof{A}\\
    \morph{isEmpty} &: \discof{\downof{\termO}} \to \termO + \termO
  \end{align*}

\item For any finite family of objects $(A_i)_i$, distributive maps
  \begin{align*}
    \disco_\x &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \disco_+ &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item \emph{Semilattice objects}, \emph{fixed point objects}, and \emph{equality
  objects} (see \cref{sec:object-families}).

\end{enumerate}

You may notice that we not imposed any \emph{laws}; lacking laws, there is no
useful general equational theory of Datafun models. Instead, our approach is to
relate the models we construct to the standard \Poset{} model and use \emph{its}
equational theory. \Cref{fig:general-semantics} shows how to interpret Datafun
into any Datafun model.


%% ---- Syntax & semantics figures ----
\newcommand\cxs[2]{{\isocolor #1}\mathop{;}#2}
\newcommand\emptycx{}

\newcommand\eqt[1]{\underaccent{\mathrm{eq}}{#1}}
\newcommand\eeq[2]{#1 = #2}

%% TODO: variadic tuples & sums?
\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& \tbool \bnfor \tset{A} \bnfor
    \iso A \bnfor A \to B \bnfor A \x B \bnfor A + B
    \\
    \text{semilattices} & L,M &\bnfeq& \tbool \bnfor \tset{A} \bnfor
    A \to L \bnfor L \x M
    \\
    \text{eqtypes} & \eqt A, \eqt B &\bnfeq& \tbool \bnfor \tset{\eqt A} \bnfor
    \isof{\eqt A} \bnfor \eqt A \x \eqt B \bnfor \eqt A + \eqt B
    \\[.2em]
    \text{terms} & e,f,g &\bnfeq& x \bnfor {\isocolor x} \bnfor \fnof{x} e \bnfor e\<f
    \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
    &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
    &&&\etrue \bnfor \efalse \bnfor \eif e f g\\
    &&&\bot \bnfor e \vee f \bnfor \esetd{e_i}_i \bnfor \eford{x}{e} f
    \bnfor \ewhen e f\\
    &&& \eboxd e \bnfor \elet{\eboxd x = e} f \bnfor \splitsum e \bnfor \eeq{e}{f}
    \bnfor \efix e
    \\[2ex]
    \text{contexts} & \Omega &\bnfeq& \cxs\Psi\G
    \\
    \text{semicontexts} & \Psi,\G &\bnfeq& (x_i : A_i)_i
  \end{array}\]
  \caption{Syntax of Datafun}
  \label{fig:syntax}
\end{figure*}

%\newcommand\J[3]{{#1} \mathrel{\,:\,} {#2} \vdash {#3}}
\newcommand\J[3]{{#2} \vdash {#1} \mathrel{:} {#3}}
\newcommand\h[2]{{#1} : {#2}}

\begin{figure*}
  \begin{mathpar}
    \infer{\isocolor \h x A \in \Psi}{\J {\isocolor x} {\cxs\Psi\G} A}

    \infer{\h x A \in \G}{\J x {\cxs\Psi\G} A}

    \infer{\J e {\cxs\Psi{\G,\h x A}} B}{\J{\fnof x e}{\cxs\Psi\G}{A \to B}}

    \infer{\J e \Omega {A \to B} \\ \J f \Omega A}{\J {e\<f} \Omega B}

    \infer{(\J{e_i}\Omega{A_i})_i}{\J{\etuple{e_1,e_2}} \Omega {A_1 \x A_2}}

    \infer{\J e \Omega {A_1 \x A_2}}{\J{\pi_i\<e}\Omega{A_i}}

    \infer{\J e \Omega A_i}{\J{\inj i e}\Omega{A_1 + A_2}}

    \infer{\J e {\cxs\Psi\G} {A_1 + A_2} \\
      (\J {f_i} {\cxs\Psi{\G,\h {x_i} {A_i}}} {B})_i
    }{
      \J{\ecase{e} (\inj i {x_i} \caseto f_i)_i}{\cxs\Psi\G}{B}
    }

    \infer{\quad}{\J \etrue \Omega \tbool}

    \infer{\quad}{\J \efalse \Omega \tbool}

    \infer{\J e \Omega {\isof\tbool} \\ (\J{f_i}\Omega B)_i}{
      \J {\eif e{f_1}{f_2}} \Omega {B}
    }

    \infer{\J e \Omega \tbool \\ \J f \Omega L}{\J {\ewhen e f} \Omega L}

    \infer{\quad}{\J\bot\Omega L}

    \infer{(\J{e_i}\Omega L)_i}{\J{e_1 \vee e_2}\Omega L}

    \infer{(\J{e_i}{\cxs\Psi\emptycx}{A})_i}{
      \J{\esetd{e_i}_i}{\cxs\Psi\G}{\tset{A}}}

    \infer{
      \J e {\cxs\Psi\G} {\tset A} \\
      \J f {\cxs{\Psi,\h x A}\G} L
    }{\J{\eford x e f}{\cxs\Psi\G}{L}}

    \infer{\J e {\cxs\Psi\emptycx} A}{\J{\eboxd e}{\cxs\Psi\G}{\isof A}}

    \infer{\J e {\cxs\Psi\G} {\isof A}\\
      \J f {\cxs{\Psi,\h x A}\G} B
    }{\J {\elet{\eboxd x = e} f} {\cxs\Psi\G} B}

    \infer{\J e \Omega {\isof{(A + B)}}}{\J{\splitsum e} \Omega {\isof A + \isof B}}

    \infer{(\J {e_i} \Omega {\isof{\eqt A}})_i}{\J {\eeq{e_1}{e_2}} \Omega \tbool}

    \infer{\J e \Omega {\isof{(\eqt L \to \eqt L)}}
    }{\J{\efix e} \Omega {\eqt L}}
  \end{mathpar}

  \caption{Typing rules of Datafun}
  \label{fig:typing-rules}
\end{figure*}

\begin{figure*}[p]
  \begin{mathpar}
    \den{A} : \catC

    \den{\J e \Omega A} : \den{\Omega} \to \den{A} : \catC

    \morph{dist}^\x_+ : A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)
  \end{mathpar}

  \begin{align*}
    \den{\tbool} &= \downof{\termO} & \den{A \to B} &= \den{A} \homto \den{B}
    \\
    \den{\tset{A}} &= \downof{\den{A}} & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{{\isocolor x}} &= \XXX \quad \text{(for discrete $\isocolor x$)}
    & \den{x} &= \XXX \quad \text{(for monotone $x$)}
    \\
    \den{\fnof x e} &= \XXX
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e,f}} &= \fork{\den{e},\den{f}}
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \den{\inj i e} &= \den{e} \then \injc_i
    \\
    \den{\efalse} &= \bot
    & \den{\etrue} &= \termI{} \then \morph{singleton}
    \\
    \den{\bot} &= \bot
    & \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}
    \\
    %% FIXME: wrong denotation
    \den{\esetd{e_i}_i} &=
    \color{red} \fork{\den{e_i} \then \morph{singleton}}_i \then \morph{join}
    \\
    \bigden{\eboxd e} &= \XXX \then \discof{(\XXX \then \den e)}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\idmorph, \den{e}} \then \XXX \then \den{f}
    \\
    \den{\splitsum e} &= \den{e}\then W_+ &
    \den{\eeq{e}{f}} &= \fork{\den{e},\den{f}} \then \morph{eq}
  \end{align*}

  \begin{align*}
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\idmorph, \den{e}} \then \morph{dist}^\x_+
    \then \bigkrof{\XXX \then \den{f_i}}_i
    \\
    \den{\eif e {f_1}{f_2}}
    &= \fork{\idmorph, \den e \then \morph{isEmpty}}
    \then \morph{dist}^\x_+ \then \bigkrof{\pi_1 \then \den{f_i}}_i
    \\
    \den{\ewhen e f} &= \fork{\idmorph, \den{e}} \then \morph{strong}
    \then \downof{(\pi_1 \then \den{f})} \then \morph{collect}
    \\
    \den{\eford x e f} &= \fork{\idmorph,\den{e}} \then \morph{strong}
    \then \downof{(\XXX \then \den{f})} \then \morph{collect}
  \end{align*}

  \todo{FIXME: denotation set literals is wrong, doesn't account for context stripping!}

  \todo{TODO: $\den{\efix e}$}

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \down}$}
  \label{fig:general-semantics}
\end{figure*}


\subsection{Object families}
\label{sec:object-families}

To be a Datafun model, semilattice types must be interpreted into
\emph{semilattice objects}; equality types must be interpreted into
\emph{equality objects}; and fixed point types must be interpreted into
\emph{fixed point objects}. A given object $A$ is:


\begin{itemize}
\item A semilattice object when equipped with an \down-algebra $\morph{collect} :
  \downof{A} \to A$ and a family of morphisms $\morph{join}_n : A^n \to A$.

\item An equality object when equipped with a morphism $\morph{eq} : \discof A \x
\discof A \to \downof \termO$.

\item A fixed point object when equipped with a morphism $\morph{fix} : \discof{(A
  \homto A)} \to A$.
\end{itemize}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations inv\-olv\-ing \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent
Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we
recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
(\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
identity and associativity laws of a category, but $\zero$ will be useful
nonetheless. We will see how to duck this non-constructive use of the axiom of
choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\oplus$ and showing the
existence of derivatives.


\subsection{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value-level structure is inherited from \Poset{} along \valfn{}. The
  change-poset structure is also inherited from \Poset{}, while the projection
  and injection's derivatives operate pointwise on changes:

  \begin{align*}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\
    \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
    \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

  \begin{gather*}
    \fork{f_i}_i \<(x \upd \dx)
    = (f_i(x \upd \dx))_i
    = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
    = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
  \end{gather*}

  \noindent
  A derivative for split must obey \[ \krof{f_i}_i\<(\inj i x \upd \inj i \dx)
  = f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx) \] so one
  valid choice is

  \[\deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
  \]

  \noindent
  The second case is dead code; any value of the right type would do. We will
  exploit this later to avoid needing the axiom of choice (used to define
  $\zero_x$) in the context of Datafun.
\end{proof}


\subsection{Exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have
%
\[ (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \]
%
and more generally, \cref{eqn:function-update} can be rewritten:
%
\begin{equation*}
  f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx)
\end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


\subsection{The lifted \iso{} comonad}

\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map:

\begin{align*}
  \chgs{\isof A} &= \isof{\chgs A}
  &
  x \oplus_{\isof A} \dx = y &\iff x = y \wedge x \oplus_A \dx = y
\end{align*}

\noindent
So changes are ordered discretely, and \emph{only zero-changes are valid}. This
maintains soundness \& completeness for increases, since $x \le y : \isof A \iff
x = y$.

Functoriality is straightforward to verify:

\begin{align*}
  \iso_\CP(f) = \iso_\Poset(f) = f
  && \deriv{\iso_\CP(f)} = \deriv{\iso_\Poset(f)} = \deriv f
\end{align*}

\noindent
To show $\iso$ is a comonad, it's easy to see that ${\iso} = {\iso\iso}$, so the
duplication natural transformation $\delta : {\iso} \to {\iso\iso}$ is the
identity; the extraction natural transformation $\varepsilon : {\iso} \to
\mathbold{1}$ is given by the subposet inclusion from $\isof A$ to $A$, with
$\deriv{\varepsilon_A} \<x \<\dx = \dx$.

Finally, $\iso_\CP$, like $\iso_\Poset$, distributes over products \& sums. This
follows from the definitions of $\chgs{\iso A}$ and $\updfn_{\iso A}$ and of
products and sums in $\CP$.


\subsection{Semilattice and fixed-point structure}

\todo{TODO}


\section{Incrementalization}
\label{sec:incremental}

\todo{TODO: explain incremental semantics --- it's the ``obvious'' categorical
  semantics in \CP{}. Read off the incrementalization transform. To do this we
  need to fix our non-constructive use of $\zero$, which we do via
  $\fname{dummy} : A \to \chgs A$.}

\newcommand\expandsto{\rightsquigarrow}
\begin{figure*}
  %% TODO: pattern-matching on box types.
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\expandsto& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
    \\[.33em]
    \ecase{e} x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{x = e} f
    \\[.33em]
    \ecase{e} \eboxd x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{\eboxd x = e} f
    \\[.33em]
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\expandsto& \elet{x = e}\\
    && \ecase{\pi_1\< x,\, \pi_2\< x} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\expandsto& \elet{\eboxd x = e}\\
    && \ecase{\eboxd{\pi_1\<x}, \eboxd{\pi_2\<x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\expandsto& \ecase{e} (\inj i x \caseto \ecase{x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\expandsto& \ecase{\splitsum e} (\inj i \eboxd{p_i} \caseto f_i)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
\end{figure*}

\renewcommand\extract{\error{don't use extract}}
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.3em}\begin{array}{lcl}
      \dummy &:& A \to \D A\\
      \dummy \<(\pwild : \tbool) &=& \efalse\\
      \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
      \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
      \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
      \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
      %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
      \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
    \end{array}
    %%
    %% \begin{array}{l}
    %%   \extract_i ~:~ A_i \to \D A_1 + \D A_2 \to \D A_i\\
    %%   \extract_i\<x\<\dx = \ecase{\dx} \inj i \dx \caseto \dx;\;%\\
    %%   %\phantom{\extract_i\<x\<\dx = \ecase{\dx}}
    %%   \pwild \caseto \dummy\<x
    %%   %\quad\ {\color{ACMPurple} \longleftarrow \textit{Dead code.}}
    %% \end{array}
  \end{mathpar}
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \delta x &= \dx\\
    \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
    \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
    \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
    \delta (\pi_i\<e) &= \pi_i\< \delta e\\
    \delta (\inj i e) &= \inj i {\delta e}\\
    \delta \bot &= \bot &
    \delta (e \vee f) &= \delta e \vee \delta f\\
    \delta \etrue = \delta \efalse &= \efalse
    & \delta\esetd{e_i}_i &= \eset{}\\
    \delta \eboxd{e} &= \eboxd{\delta e}
    & \delta(\splitsum e) &= \splitsum \delta e
  \end{align*}

  \begin{align*}
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
    \\
    \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
    \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
    \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
    \delta (\eford x e f)
    &= (\eford x {\delta e} f)\\
    &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
    \delta (\ecase e (\inj i x \caseto f_i)_i)
    %% &= \ecase{\splitsum{\eboxd e}}\\
    %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
    &= \ecase{\splitsum{\eboxd e},\, \delta e}\\
    &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
    &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
    %\elet{\dx = \dummy\<x}
    \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
  \end{align*}
  \caption{The derivative translation}
  \label{fig:derivatives}
\end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\todo{TODO: explain faster-fix?}

\todo{TODO: explain semi\naive{} semantics --- it's the same except we interpret
  $\iso$ as $\blackiso$ and fix as fast-fix. Read off the semi\naive{}
  transform.}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}

\begin{figure*}
  \begin{align*}
    \Phi \tbool &= \tbool & \D\tbool &= \tbool\\
    \Phi \tset{A} &= \tset{\Phi A} & \D\tset{A} &= \tset{\Phi A}\\
    \Phi \isof A &= \isof{(\Phi A \x \D A)}
    & \D\isof A &= \isof \D A\\
    \Phi(A \to B) &= \Phi A \to \Phi B
    & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
    \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
    \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
  \end{align*}
  \caption{Semi\naive{} type translation}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \phi x &= x & \delta x &= \dx\\
    \phi(\fnof x e) &= \fnof x \phi e
    & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
    \phi(e\<f) &= \phi e\<\phi f
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
    & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
    \phi(\pi_i\<e) &= \pi_i\<\phi e
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \phi(\inj i e) &= \inj i \phi e
    & \delta(\inj i e) &= \inj i \delta e\\
    \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
    \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
    \phi\bot &= \bot & \delta\bot &= \bot\\
    \phi(e \vee f) &= \phi e \vee \phi f
    & \delta(e \vee f) &= \delta e \vee \delta f\\
    \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    & \delta\eboxd{e} &= \eboxd{\delta e}
  \end{align*}

  %% TODO: determine exactly how much syntax sugar I want to allow in the target
  %% of this translation. for example, the case-split I use in \phi(\splitsum e)
  %% is only valid *because* \splitsum exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

  %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
  %% TODO FIXME: \phi(if then else), \delta(if then else)!

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\splitsum{\eboxd{\phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\splitsum{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    \phi(\eford x e f)
    &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\phi f}{\dx \substo \zero\<x}
    \\
    \delta(\eford x e f)
    &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
    \\
    \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
    \\
    \delta(\ewhen e f)
    &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
    \\
    \phi(\splitsum e) &=
    %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
    %% &\phantom{{}={}} \ecase{\splitsum{\eboxd y}}\\
    %% &\qquad (\inj i \eboxd x \caseto
    %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
    %%
    %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
    %% &\phantom{{}={}}\ecase{\splitsum {\eboxd x}, \splitsum {\eboxd\dx}}\\
    %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
    %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
    %% &\qquad (\inj i \eboxd x, \pwild
    %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
    %%
    \elet{\eboxd{x} = \phi e}\\
    &\phantom{{}={}} \splitsum [\isocolor \ecase x\\
    &\phantom{= \splitsum}\quad\isocolor
      (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    &\phantom{= \splitsum}\quad
      {\isocolor(\etuple{\inj i y, \pwild}
        \caseto \inj i \etuple{y, \dummy\<y})_i}]
    %%
    %% \ecase{\phi e}\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
    %% \caseto \inj i \eboxd{x,\dx})_i\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
    %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
    \\
    \delta(\splitsum e) &= \splitsum \delta e
  \end{align*}
  \caption{Semi\naive{} term translation}
\end{figure*}

\subsection{The \blackiso{} comonad}

\todo{TODO: explain $\blackiso$}

\end{document}
