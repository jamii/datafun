%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=18cm,width=38em,width=420pt,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=152mm,width=351pt,width=373pt,]{narrow}
\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\pagestyle{empty}

%\documentclass{rntz}\usepackage{fantasy}%\geometry{textwidth=330pt,}
%\documentclass[nomarginums]{rntz}\usepackage[tablet]{fantasy}%\geometry{textwidth=345pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}
\usepackage{thmtools,thm-restate}   % allow restatable theorems.

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
%\usepackage[skip=.5\baselineskip,labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}
\usepackage[labelfont=sc,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4
%\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy[laptop,tablet]
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}
%\usepackage[source,scaled=1.01,linespread=1.0132,linespread=1.015,]{rntzfont}
%\usepackage[librebaskerville,linespread=1.012,]{rntzfont} % zeu@Scale â‰ˆ .98

%% %% Nice for fantasy[phone].
%% \usepackage[sfdefault,scaled=.89060]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.04}\makeatother
%% \usepackage[cal=cm,bb=esstix,scaled=.93,bbscaled=.93]{mathalfa}
%% \renewcommand\mathit\textit\renewcommand\mathrm\textmd % argh
%% \usepackage[basic,defaultmathsizes]{mathastext}
%% \linespread{1.05}%\linespread{1.08}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}

\usepackage{notation}


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}%\the\textwidth

%% \noindent
%% % use a math environment to force loading math font.
%% ex/em: \the\fontdimen5\font{} / \the\fontdimen6\font \(\)\\
%% math ex: \the\fontdimen5\textfont1{} / \the\fontdimen6\textfont1\\
%% word space: \the\fontdimen2\font\\
%% baselineskip: \the\baselineskip\\
%% %% \par\begingroup\Large\noindent
%% %% x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} $f$f $t$t $o$o $T$T\emph{T} lIx\\
%% %% fb ff fh fi fj fk fl ft \emph{fb ff fh fi fj fk fl ft} Th \emph{Th}\\
%% %% ffb ffh ffi ffj ffk ffl fft \emph{ffb ffh ffi ffj ffk ffl fft}
%% %% \endgroup\\

\maketitle

\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (\cref{sec:datafun-models}). With this in mind, we define
a category \CP{} of posets equipped with a notion of \emph{increasing changes},
whose morphisms are monotone maps possessing \emph{derivatives} relating input
changes to output changes (\cref{sec:changeposets}). This gives us an
\emph{incremental semantics} for Datafun (\cref{sec:incremental}). We observe
that one can compute the fixed point of a function more efficiently using its
derivative, and in a higher-order language function derivatives are \emph{zero
  changes}. We give a \emph{``semi\naive{}''} static transformation on Datafun
that augments the discreteness comonad to compute zero-changes. We prove this
correct by relating it to the incremental semantics.

% TODO: more section links once I finish them.


%% ---- Syntax & typing rules ----
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
      \text{types} & A,B &\bnfeq& \isof A \bnfor \tset{\eqt A}
      \bnfor \tunit \bnfor A \x B \bnfor A + B \bnfor A \to B
      \\
      \text{eqtypes} & \eqt A, \eqt B &\bnfeq&
      \isof{\eqt A} \bnfor \tset{\eqt A} \bnfor
      \tunit \bnfor \eqt A \x \eqt B \bnfor \eqt A + \eqt B
      \\
      \text{semilattices} & L,M &\bnfeq&
      \tset{\eqt A} \bnfor \tunit \bnfor L \x M \bnfor A \to L
      \\[.5em]
      \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
      \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
      &&& \inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
      &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
      &&& \bot \bnfor e \vee f \bnfor \esetd{e_i}_i \bnfor \eford x e f\\
      &&& \eeqd e f \bnfor \eisEmpty e \bnfor \esplit e \bnfor \efix e
      \\[.5em]
      \text{contexts} & \G &\bnfeq& (H_i)_i\\
      \text{hypotheses} & H &\bnfeq& \h x A \bnfor \hd x A
    \end{array}
    \\
    \stripcxd\G = (\hd x A)_{\hd x A \in \G}
    \\
    \infer{\h x A \in \G}{\J x \G A}

    \infer{\hd x A \in \G}{\J {\dvar x} \G A}

    \infer{\J e {\G,\h x A} B}{\J {\fnof x e} \G {A \to B}}

    \infer{\J e \G {A \to B} \\ \J f \G A}{\J {e\<f} \G B}

    \infer{\quad}{\J {\etuple{}} \G \tunit}

    \infer{(\J{e_i}\G{A_i})_i}{\J{\etuple{e_1,e_2}} \G {A_1 \x A_2}}

    \infer{\J e \G {A_1 \x A_2}}{\J{\pi_i\<e}\G{A_i}}

    \infer{\J e \G A_i}{\J{\inj i e}\G{A_1 + A_2}}

    \infer{\J e \G {A_1 + A_2} \\
      (\J {f_i} {\G,\h {x_i} {A_i}} {B})_i
    }{
      \J {\ecase{e} (\inj i {x_i} \caseto f_i)_i} \G B
    }

    \infer{\J {\isocolor e} {\stripcxd\G} A}{\J{\eboxd e} \G {\isof A}}

    \infer{\J e \G {\isof A} \\ \J f {\G,\hd x A} B}{
      \J {\elet{\eboxd x = e} f} \G B}

    \infer{\quad}{\J\bot\G L}

    \infer{(\J{e_i}\G L)_i}{\J{e_1 \vee e_2}\G L}

    %% \infer{\J e \G {\eqt A}}{\J {\edown e} \G {\tdown {\eqt A}}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}{
      \J {\esetd{e_i}_i} \G {\tset{\eqt A}}}

    %% \infer{\J e \G {\tdown {\eqt A}} \\
    %%   \J f {\G,\h x {\eqt A}} L
    %% }{\J {\ebigvee x e f} \G L}
    %%
    \infer{
      \J e \G {\tset A} \\
      \J f {\G,\hd x A} L
    }{\J {\eford x e f} \G L}

    %%\infer{\J e \G {\isof{(\eqt A \x \eqt A)}}}{\J{\prim{eq}\<e} \G {\tdown\tunit}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}
          {\J {\eeqd{e_1}{e_2}} \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} {\tset\tunit}}{
      \J {\eisEmpty e} \G {\tunit + \tunit}}

    \infer{\J e \G {\isof{(A + B)}}}{\J{\esplit e} \G {\isof A + \isof B}}

    \infer{\J e \G {\isof{(\eqt L \to \eqt L)}}}{\J{\prim{fix}\< e} \G {\eqt L}}
  \end{mathpar}

  \caption{Datafun core syntax and typing rules}
  \label{fig:core-datafun}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& ... \bnfor \tbool\\
    \text{terms} & e,f,g &\bnfeq&
    ... \bnfor \efalse \bnfor \etrue \bnfor \eif e f g \bnfor \ewhen e f\\
    &&& \edcase{e} (\inj i {\dvar{x_i}} \caseto f_i)_{i\in\{1,2\}} \bnfor \efixisd x e
  \end{array}\]

  \begin{mathpar}
    \infer{\quad}{\J \etrue \G \tbool}

    \infer{\quad}{\J \efalse \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} \tbool \\ (\J{f_i}\G B)_i}
          {\J {\eifd e{f_1}{f_2}} \G {B}}

    \infer{\J e \G \tbool \\ \J f \G L}{\J {\ewhen e f} \G L}

    \infer{\J {\isocolor e} {\stripcxd{\G}, \h x {\eqt L}} {\eqt L}}
          {\J {\efixisd x e} \G {\eqt L}}
  \end{mathpar}

  \caption{Surface syntax and typing rules}
  \label{fig:surface-syntax}
\end{figure*}

\begin{figure*}
  \[\tbool \desugars \tset{\tunit}\]

  \begin{align*}
    \efalse &\desugars \esetd{} &
    \etrue &\desugars \esetd{\etuple{}}
    \\
    \ewhen e f &\desugars \eford {\freshvar\pwild} e f &
    \efixisd x e &\desugars \efix \eboxd{\fnof {\color{black} x} e}
  \end{align*}

  \begin{align*}
    %% \eeqd e f &\desugars \prim{eq}\< \eboxd{\etuple{e, f}}\\
    %% \esetd{e_i}_i &\desugars \edown\eboxd{e_0} \vee ... \vee \edown\eboxd{e_n} \quad \text{(or $\bot$ if $n=0$)}\\
    %% \eford x e f &\desugars \ebigvee {\freshvar y} e {\elet{\eboxd x = \freshvar y} f}\\
    \eifd e {f_1}{f_2} &\desugars
    \ecase{\eisEmpty e} (\inj i {\freshvar\pwild} \caseto f_i)_i\\
    \edcase e (\inj i {\dvar{x_i}} \caseto f_i)_i
    &\desugars \ecase{\esplit \eboxd e}
    (\inj i {\freshvar y} \caseto \elet{\eboxd{x_i} = \freshvar y} f_i)_i
  \end{align*}

  %\vspace{-.5ex}
  {\small Fresh variables ($\freshvar y$, $\freshvar\pwild$) are marked in \freshvar{pink}.}

  \vspace{.5ex}
  %% TODO: consider the pattern-matching desugaring in "Some pattern-matching
  %% elaboration rules". if we have that, we probably don't also need \edcase.
  %% Only include one in final paper.
  \caption{Desugaring of surface syntax}
  \label{fig:desugaring}
\end{figure*}

%% TODO: do we need all of these?
\begin{figure*}
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\desugars& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
    \\[.33em]
    \ecase{e} x \caseto f;\ (p_i \caseto g_i)_i
    &\desugars& \elet{x = e} f
    \\[.33em]
    \ecase{e} \eboxd x \caseto f;\ (p_i \caseto g_i)_i
    &\desugars& \elet{\eboxd x = e} f
    \\[.33em]
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\desugars& \elet{x = e}\\
    && \ecase{\pi_1\< x,\, \pi_2\< x} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\desugars& \elet{\eboxd x = e}\\
    && \ecase{\eboxd{\pi_1\<x}, \eboxd{\pi_2\<x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\desugars& \ecase{e} (\inj i x \caseto \ecase{x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\desugars& \ecase{\esplit e} (\inj i \eboxd{p_i} \caseto f_i)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
\end{figure*}


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,

  \nopagebreak[2]
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:

  \begin{eqnarray*}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{eqnarray*}
\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive maps:

  \nopagebreak[2]
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``finite powerset''} functor \(\pfin : \catC \to \catC\) equipped
  with maps:

  \nopagebreak[2]
  \begin{align*}
    \morph{gen}_A &: \isof A \to \pfinof{A} &
    \morph{isEmpty} &: \discof{\pfinof{\termO}} \to \termO + \termO
  \end{align*}

  \noindent
  and, moreover, for any semilattice object $C$ and morphism $f : A \x \isof B
  \to C$, a ``collecting'' morphism \( \pcollect{f} : A \x \pfinof B \to C \).

\item \emph{Equality}, \emph{semilattice}, and \emph{fixed point objects}, which
  must interpret equality, semilattice, and fixed point types respectively. An
  object $A$ is:

  \begin{itemize}
  \item An equality object if equipped with a morphism $\morph{eq} : \discof A
    \x \discof A \to \pfinof \termO$.

  \item A semilattice object if equipped with morphisms $\morph{join}_n : A^n
    \to A$ for every $n : \N$.

  \item A fixed point object if equipped with a morphism $\morph{fix} :
    \discof{(\expO A A)} \to A$.
  \end{itemize}

\end{enumerate}

\noindent
\Cref{fig:general-semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \pfin{} be the finite powerset functor.
\todo{TODO: explain in more detail?}

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


%% ---- Semantics in a Datafun Model ----
\newcommand\figsectionname\textsc
\begin{figure*}
  \figsectionname{Types and Contexts}

  \begin{align*}
    \den{\tunit} &= \termO & \den{A \to B} &= \expO{\den{A}}{\den{B}}
    \\
    \den{\tseteq A} &= \pfinof{\den{\eqt A}}
    & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{\G} &= \prod_{H \in \G} \den{H} &
    \den{\h x A} &= \den{A} & \den{\hd x A} &= \discof{\den{A}}
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Terms}

  \begin{align*}
    \den{\dvar x} &= \pi_{\dvar x} \then \varepsilon \quad \text{($\dvar x$ discrete)}
    & \den{x} &= \pi_x \quad \text{($x$ monotone)}
    \\
    \den{\fnof x e} &= \lambda\den{e}
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e_i}_i} &= \fork{\den{e_i}}_i
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \bigden{\eboxd e} &= \morph{strip} \then \discof{\den e}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\id, \den{e}} \then \den{f}
    \\
    \den{\bot} &= \termI \then \morph{join}_0
    &
    \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}_2
    \\
    %\den{\color{red}\prim{isEmpty}\<e} &= \den{e} \then \morph{isEmpty}
    \den{\eisEmpty e} &= \den{\eboxd e} \then \morph{isEmpty}
    & \den{\esplit e} &= \den{e}\then \discosum
    \\
    %\den{\color{red}\prim{eq}\<e} &= \den{e} \then \morph{eq}
    \den{\eeqd{e_1}{e_2}} &= \fork{\den{\eboxd{e_i}}}_i \then \morph{eq}
    & \den{\efix e} &= \den{e} \then \morph{fix}
    \\
    %\den{\edown e} &= \den{e} \then \morph{gen}
    \den{\esetd{e_i}_i} &= \fork{\den{\eboxd{e_i}} \then \morph{gen}}_i \then \morph{join}
    &
    \den{\eford x e f} &=
    \fork{\id,\den{e}} \then \pcollect{\den{f}}
    %\den{\ebigvee x e f} &=
    %\fork{\id,\den{e}} \then \morph{strong} \then \downof{\den{f}} \then \morph{collect}
  \end{align*}

  \begin{align*}
    \den{\inj i e} &= \den{e} \then \injc_i
    \\
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\id, \den{e}} \then \morph{dist}^\x_+ \then \bigkrof{\den{f_i}}_i
    %\bigkrof{\den{f_i}}_i \circ \morph{dist}^\x_+ \circ \fork{\id, \den{e}}
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Lemmas}

  \begin{align*}
    \morph{dist}^\x_+ &: A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)\\
    % this could be simpler if it distributed in the opposite direction.
    \morph{dist}^\x_+ &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    \\[1ex]
    \morph{strip} &: \den\G \to \discof{\den{\stripcxd\G}}\\
    \morph{strip} &= \fork{\pi_{\dvar x} \then \delta}_{\hd x A \in \G} \then \discox
  \end{align*}

  %% \raggedright\footnotesize Strictly speaking, the cases for
  %% $\den{\esetd{e_i}_i}$, $\den{\eisEmpty e}$, and $\den{\eeqd e f}$ are not
  %% structurally inductive; nonetheless $\den{e}$ is well-defined.

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \pfin}$}
  \label{fig:general-semantics}
\end{figure*}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations inv\-olv\-ing \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\nopagebreak[2]
\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent In particular, for every $x$ there is a (not necessarily unique)
\emph{zero change}, $\zero_x$, such that $x \upd \zero_x = x$.\footnote{Use of
  the $\zero_x$ operator amounts to invoking the axiom of choice.}

Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\nopagebreak[2]
\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:

\nopagebreak[2]
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

%% % Doesn't work on narrow paper, eg. a5.
%% \nopagebreak
%% \[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}
%% \quad\text{or equivalently}\quad
%% f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\nopagebreak[2]
\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


%\subsection{Zero changes and change composition}

%% Applying the axiom of choice to soundness \& completeness for increases, we
%% recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
%% (\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
%% identity and associativity laws of a category, but $\zero$ will be useful
%% nonetheless. We will see how to duck this non-constructive use of the axiom of
%% choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\upd$ and showing the
existence of derivatives.


\subsection{Cartesian structure}
\label{sec:CP-cartesian}

\CP{} has all finite products and sums. The value-level structure is inherited
from \Poset{} along \valfn{}. The change-poset structure is also inherited from
\Poset{}, while the projection and injection's derivatives operate pointwise on
changes:

\nopagebreak[2]
\begin{align*}
  \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
  \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
  %\label{eqn:delta-distributes-over-sums-and-products}
  \\
  \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
\end{align*}

\noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
undefined for $i \ne j$:

\nopagebreak[2]
\begin{align*}
  (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
  \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
\end{align*}

\noindent
Soundness \& completeness for increases follow directly from the pointwise
orderings of products \& coproducts in \Poset{}.

Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

\nopagebreak[2]
\begin{equation*}
  \fork{f_i}_i \<(x \upd \dx)
  = (f_i(x \upd \dx))_i
  = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
  = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
\end{equation*}

\noindent
A derivative for split must obey

\nopagebreak[2]
\begin{equation*}
\krof{f_i}_i\<(\inj i x \upd \inj i \dx)
= f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx)
\end{equation*}

\noindent
so one valid choice is

\nopagebreak[2]
\begin{equation*}
  \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
\end{equation*}

\noindent
The second case is dead code; any value of the right type would do. We will
exploit this in \cref{sec:incremental} to avoid needing the axiom of choice
(used to define $\zero_x$) in the context of Datafun.


\subsection{Exponentials}
\label{sec:CP-exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\nopagebreak[2]
\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have

\nopagebreak[2]
\begin{equation*} (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \end{equation*}

\noindent
and more generally, \cref{eqn:function-update} can be rewritten:

\nopagebreak[2]
\begin{equation*} f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx) \end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\nopagebreak[2]
\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Î“ x A -> B
%% Exists Î»f : Î“ -> (A => B)
%% such that f = (Î»f Ã— id); eval

% WTS: f â‰¤ g â‡” âˆƒdf. f -df-> g

% Suppose f â‰¤ g.
% WTS: âˆƒdf. f --df--> g.
% Let's calculate! df has to be such that
% âˆ€(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


%% TODO: maybe call this \iso_{\boldsymbol\Delta} instead?
\subsection{The lifted \iso{} comonad and its relatives}
\label{sec:CP-iso}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map. Since $\isof A$ is ordered discretely,
values \emph{cannot} increase. So the simplest definition that is sound and
complete for increases is:

\nopagebreak[2]
\begin{align*}
  \chgs{\isof A} &= \termO
  &
  x \upd_{\isof A} \tuple{} = x
\end{align*}

\noindent
Functoriality, extraction, duplication, and product- and sum-distribution all
refine the corresponding properties of $\iso_\Poset$, and their derivatives are
fairly straightforward:
%
\begin{mathpar}
  \deriv{\iso(f)} \<x \<\tuple{} = \tuple{}

  \deriv\delta_A \<x \<\tuple{} = \tuple{}

  \deriv\varepsilon_A \<x \<\tuple{} = \zero_x
  \\
  \deriv{{\discox}} \<x \<\dx = \tuple{}

  \deriv{{\discosum}} \<(\inj i x) \<\tuple{} = \inj i {\tuple{}}
\end{mathpar}


\subsubsection{The alternative \altiso}

Although we will not use it, there is another refinement of $\iso$ in \CP{},
which I'll call $\altiso$ for clarity, defined like so:

\nopagebreak[2]
\begin{align*}
  \chgs{\altiso A} &= \altiso \chgs A
  &
  x \upd_{\altiso A} \dx = y &\iff x = y \wedge x \upd_A \dx = y
\end{align*}

\noindent
So $\altiso A$ inherits all of $A$'s changes, but ordered discretely and with
\emph{only zero-changes still valid}. The derivatives of functoriality,
duplication, and extraction are different:

\nopagebreak[2]
\begin{align*}
  \deriv{\altiso(f)} &= \deriv f
  & \deriv\delta_A \<x\<\dx &= \dx
  & \deriv\varepsilon_A \<x\<\dx &= \dx
\end{align*}

\noindent
Observe that we no longer need the non-constructive $\zero_x$ to define comonad
extraction $\varepsilon$! However, for our purposes this will not be an issue.
Meanwhile, product- and sum-distribution become identity maps, because $\prod_i
\altiso A_i = \altiso \prod_i A$ and $\sum_i \altiso A_i = \altiso \sum_i
A_i$.\footnote{Checking this is left as an exercise for the reader.}


\subsection{The lifted \pfin\ functor}
\label{sec:CP-pfin}

We lift the finite powerset functor \pfin\ to \CP\ as follows:

\nopagebreak[2]
\begin{align*}
  \chgs{\pfinof A} &= \pfinof{\vals A} &
  x \upd_{\pfinof A} \dx &= x \cup \dx
\end{align*}

\noindent
Derivatives of \morph{gen}, \morph{isEmpty}, and $\pcollect f$ are
given by:

\nopagebreak[2]
\begin{align*}
  f &: \G \x \isof B \to L\\
  \pcollect f &: \G \x \pfinof B \to L
  \\
  \deriv{\morph{gen}}_A \<x \<\dx &= \emptyset\\
  \deriv{\morph{isEmpty}} \<x \<\tuple{} &= \morph{isEmpty} \< x\\
  \deriv{\pcollect f} \<\tuple{\gamma,a} \<\tuple{d\gamma,\da}
  &= \XXX
\end{align*}

\noindent
\todo{TODO: prove correctness of these derivatives, esp. $\deriv{\pcollect f}$. }

%% We lift the free semilattice functor $\down$ to \CP\ as follows:
%% \begin{mathpar}
%%   \chgs{\downof A} = \downof{\vals A}

%%   x \upd_{\downof A} \dx = x \vee_{\downof{\vals A}} \dx
%% \end{mathpar}

%% \noindent
%% Derivatives for its associated morphisms are:

%% \begin{align*}
%%   \morph{gen}_A &: A \to \downof{A}\\
%%   \morph{isEmpty} &: \discof{\downof{\termO}} \to \termO + \termO\\
%%   \morph{strong}_{A,B} &: A \x \downof{B} \to \downof{(A \x B)}
%%   \\
%%   \deriv{\morph{gen}}_A \<x \<\dx &= \color{red}\morph{gen} \<(x \upd \dx)
%%   \\
%%   %% shit, this sucks.
%%   \deriv{\morph{isEmpty}} \<x \<\dx &= \XXX
%%   \\
%%   %% shit, this sucks.
%%   \deriv{\morph{strong}}_{A,B} \<\tuple{a,x} \<\tuple{\da,\dx}
%%   &= \XXX
%% \end{align*}

%% \todo{FIXME: $\upd$ isn't a total function so $\deriv{\morph{gen}}$ fails!}


\subsection{Semilattice, equality, and fixed-point structure}
\label{sec:CP-families}
\XXX


\section{Incrementalization}
\label{sec:incremental}

The \emph{incremental semantics} for Datafun, notated $\incden{-}$, is given
by the Datafun model in \CP{} constructed in \cref{sec:changeposets}, letting
$\disco = \iso_\CP$ and $\pfin = \pfin_\CP$. As we took care to show while
constructing it, this \emph{refines} the standard model along the forgetful
functor $\valfn$, that is:

\begin{restatable}{theorem}{thmForget}
  \label{thm:forget}
  \(\vals{\incden{-}} = \den{-}\).
\end{restatable}

\begin{proof}
  By induction on types and typing derivations; see \cpageref{proof:forget}.
\end{proof}


%\subsection{The change type translation}
Given any Datafun type $A$, its change poset $\D\incdens A$ is internally
definable via the following translation (also named $\D$, despite the risk of
confusion):

\nopagebreak[2]
\begin{align*}
  \D\tunit &= \tunit
  & \D(A \x B) &= \D A \x \D B
  \\
  \D \isof A &= \tunit
  & \D(A + B) &= \D A + \D B
  \\
  \D\tset{\eqt A} &= \tset{\eqt A}
  & \D(A \to B) &= \isof A \to \D A \to \D B
\end{align*}

\begin{restatable}{theorem}{thmDeltaDen}
  \label{thm:delta-den}
  \(\D\incdens A = \den{\D A}\).
\end{restatable}
\begin{proof}
  Induct on types; see \cpageref{proof:delta-den}.
\end{proof}


%% ---- More figures ----
%% \begin{figure*}
%%   \begin{align*}
%%     \delta x &= \dx\\
%%     \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
%%     \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
%%     \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
%%     \delta (\pi_i\<e) &= \pi_i\< \delta e\\
%%     \delta (\inj i e) &= \inj i {\delta e}\\
%%     \delta \bot &= \bot &
%%     \delta (e \vee f) &= \delta e \vee \delta f\\
%%     \delta \etrue = \delta \efalse &= \efalse
%%     & \delta\esetd{e_i}_i &= \eset{}\\
%%     \delta \eboxd{e} &= \eboxd{\delta e}
%%     & \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \begin{align*}
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
%%     \\
%%     \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
%%     \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
%%     \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
%%     \delta (\eford x e f)
%%     &= (\eford x {\delta e} f)\\
%%     &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
%%     \delta (\ecase e (\inj i x \caseto f_i)_i)
%%     %% &= \ecase{\esplit{\eboxd e}}\\
%%     %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
%%     &= \ecase{\esplit{\eboxd e},\, \delta e}\\
%%     &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
%%     &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
%%     %\elet{\dx = \dummy\<x}
%%     \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
%%   \end{align*}
%%   \caption{The derivative translation}
%%   \label{fig:derivatives}
%% \end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\todo{TODO: explain faster-fix?}

\todo{TODO: explain this type transformation:}
\begin{align*}
  \Phi\tunit &= \tunit &
  \Phi(A \x B) &= \Phi A \x \Phi B\\
  \Phi\isof A &= \isof{(\Phi A \x \D \Phi A)} &
  \Phi(A + B) &= \Phi A + \Phi B\\
  \Phi\tset A &= \tset{\Phi A} &
  \Phi(A \to B) &= \Phi A \to \Phi B
\end{align*}

\newcommand\isocx[1]{{\color{ACMPurple}\lfloor{#1}\rfloor}}

\noindent
\Cref{fig:seminaive-phi,fig:seminaive-delta} define two mutually recursive
static transformations: $\phi e$, which computes $e$ \emph{semi\naive{}ly},
speeding up fixed point computation by using derivatives; and $\delta e$, which
computes the \emph{derivative} of $\phi e$. The type of $\delta e$ involves a
strengthening operator $\isocx{\G}$ that makes every variable in $\G$
discrete:
%
\begin{mathpar}
  \isocx{(H_i)_i} = (\isocx{H_i})_i

  \isocx{\h x A} = \hd x A

  \isocx{\hd x A} = \hd x A
\end{mathpar}

\noindent
Be careful not to confuse this with $\stripcxd{\G}$, which weakens $\G$ by
removing all \emph{except} the discrete variables from $\G$. These defined, we
have:

\begin{restatable}[Type-correctness]{theorem}{thmTypeCorrect}
  \label{thm:type-correct}
  If $\J e \G A$, then
  \[ \J {\phi e} {\Phi\G, \D\Phi\stripcxd{\G}} {\Phi A}
  \qquad\text{and}\qquad
  \J {\delta e} {\isocx{\Phi\G}, \D\Phi\G} {\D\Phi A}
  \]
\end{restatable}
\begin{proof}
  By induction on typing derivations; see \cpageref{proof:typeCorrect}.
\end{proof}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}


%% \begin{figure*}
%%   \begin{align*}
%%     \Phi \tunit &= \tunit & \D\tunit &= \tunit\\
%%     \Phi \tdown{\eqt A} &= \tdown{\Phi \eqt A} & \D\tdown{\eqt A} &= \tdown{\Phi \eqt A}\\
%%     \Phi \isof A &= \isof{(\Phi A \x \D A)}
%%     & \D\isof A &= \isof \D A\\
%%     \Phi(A \to B) &= \Phi A \to \Phi B
%%     & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
%%     \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
%%     \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
%%   \end{align*}
%%   \caption{Semi\naive{} type translation}
%% \end{figure*}


%% ---- Seminaive ("go faster") term translation ----
\begin{figure*}
  %% TODO: think about this translation and syntax sugar. for example, the
  %% case-split I use in \phi(\esplit e) is only valid *because* \esplit exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.
  \figsectionname{Interesting cases}

  \begin{align*}
    \phi(\prim{fix}\<e) &= \prim{fast-fix}\<\phi e\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \phi(\eford x e f)
    &= \eford x {\phi e} {\phi \substd{f}{dx \substo \zero\<x}}
    \\
    %% TODO: check this lines up with \delta(if then else), because that's where
    %% it comes up.
    \phi(\esplit e) &= \ecase{\phi e}\\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \inj i \dx}}
    \caseto \inj i {\eboxd {\etuple{x,\dx}}}\right)_{i\in\{1,2\}}
    \\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \pwild}}
    \caseto \inj i {\eboxd {\etuple{x, \dummy\<x}}} \right)_{i\in\{1,2\}}
    %% \phi(\esplit e) &= \color{red} \elet{\eboxd{x} = \phi e}\\
    %% &\phantom{{}={}} \esplit [\isocolor \ecase x\\
    %% &\phantom{= \esplit}\quad\isocolor
    %%   (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    %% &\phantom{= \esplit}\quad
    %%   {\isocolor(\etuple{\inj i y, \pwild}
    %%     \caseto \inj i \etuple{y, \dummy\<y})_i}]
  \end{align*}
  \vspace{0pt} % <- yes, this matters.

  \figsectionname{Distributive cases}

  \begin{align*}
    %% TODO: I should mark discrete vs. monotone variables in some
    %% (colorblind/greyscale-printing)-safe way.
    \phi x &= x & \phi \dvar x &= \dvar x\\
    \phi(\fnof x e) &= \fnof x \phi e & \phi(e\<f) &= \phi e\<\phi f\\
    \phi\etuple{e_i}_i &= \etuple{\phi e_i}_i &
    \phi(\pi_i\<e) &= \pi_i\<\phi e\\
    \phi(\inj i e) &= \inj i \phi e\\
    \phi\bot &= \bot &
    \phi(e \vee f) &= \phi e \vee \phi f\\
    \phi(\esetd{e_i}_i) &= \esetd{\phi e_i}_i &
    \phi(\eeqd e f) &= \eeqd {\phi e} {\phi f}
  \end{align*}

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \phi(\eisEmpty e) &= \eisEmpty {\phi e}
  \end{align*}

  \todo{TODO: eta-expand $\vee$ etc. at functional types! Probably do this in
    elaborator.}

  \todo{TODO: distribution of $\iso$ over sums is no longer equality! does
    $\phi(\esplit e)$ need to change?}

  \caption{Semi\naive{} speed-up translation, $\phi$}
  \label{fig:seminaive-phi}
\end{figure*}


%% ----- Figure: Seminaive Î´ derivative -----
\begin{figure*}
  \[ \delta\bot = \delta\esetd{e_i}_i = \delta(\eeqd e f) = \delta(\efix e) = \bot \]

  \begin{align*}
    \delta x &= \dx &
    \delta \dvar x &= \dvar\dx\\
    \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \delta\etuple{e_i}_i &= \etuple{\delta e_i}_i
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \delta(\inj i e) &= \inj i {\delta e} &
    \delta(e \vee f) &= \delta e \vee \delta f\\
    \delta\eboxd{e} &= \etuple{} &
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \color{Rhodamine}\phi e} \delta f\\
    \delta(\eisEmpty e) &= \eisEmpty {\color{Rhodamine} \phi e} &
    \delta(\esplit e) &= \color{red} \esplit \delta e
  \end{align*}

  \begin{align*}
    %% TODO: double-check this!
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\esplit{\eboxd{\color{Rhodamine} \phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    %% \delta(\ebigvee x e f)
    %% &= (\ebigvee x {\delta e} {\color{Rhodamine}\phi f})
    %% \vee
    %% (\ebigvee x {{\color{Rhodamine}\phi e} \vee \delta e} {\delta f})
    %% TODO: is weakening being used here?
    \delta(\eford x e f)
    &= (\eford x {\delta e} \substd{\color{Rhodamine} \phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x {{\color{Rhodamine}\phi e} \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
  \end{align*}

  \todo{TODO: double-check $\delta(\ecase e ...)$}\\
  \todo{TODO: does $\delta(\eford x e f)$ weaken $\phi f$?}\\
  \todo{TODO: since distribution of $\iso$ over sums isn't equality, doesn't
    $\delta(\esplit e)$ need to be changed?}

  \caption{Semi\naive{} derivative translation, $\delta$}
  \label{fig:seminaive-delta}
\end{figure*}


%% ---- old seminaive term translation ----
%% \begin{figure*}
%%   \begin{align*}
%%     \phi x &= x & \delta x &= \dx\\
%%     \phi(\fnof x e) &= \fnof x \phi e
%%     & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
%%     \phi(e\<f) &= \phi e\<\phi f
%%     & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
%%     \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
%%     & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
%%     \phi(\pi_i\<e) &= \pi_i\<\phi e
%%     & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
%%     \phi(\inj i e) &= \inj i \phi e
%%     & \delta(\inj i e) &= \inj i \delta e\\
%%     \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
%%     \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
%%     \phi\bot &= \bot & \delta\bot &= \bot\\
%%     \phi(e \vee f) &= \phi e \vee \phi f
%%     & \delta(e \vee f) &= \delta e \vee \delta f\\
%%     \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
%%     \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
%%     & \delta\eboxd{e} &= \eboxd{\delta e}
%%   \end{align*}

%%   %% TODO: determine exactly how much syntax sugar I want to allow in the target
%%   %% of this translation. for example, the case-split I use in \phi(\esplit e)
%%   %% is only valid *because* \esplit exists.
%%   %%
%%   %% Would be nice to give the syntax sugar explicitly, but maybe more effor
%%   %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

%%   %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
%%   %% TODO FIXME: \phi(if then else), \delta(if then else)!

%%   \begin{align*}
%%     \phi(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
%%     \\
%%     \delta(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\esplit{\eboxd{\phi e}},\, \delta e}\\
%%     &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad ({\inj i {\eboxd x},\, \pwild}
%%       \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
%%     %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
%%     %% &\qquad (\inj i \eboxd x
%%     %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
%%     %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
%%     %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
%%     \\
%%     \phi(\eford x e f)
%%     &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\phi f}{\dx \substo \zero\<x}
%%     \\
%%     \delta(\eford x e f)
%%     &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
%%     &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\delta f}{\dx \substo \zero\<x})
%%     \\
%%     \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
%%     \\
%%     \delta(\ewhen e f)
%%     &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
%%     \\
%%     \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
%%     \\
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
%%     \\
%%     \phi(\esplit e) &=
%%     %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
%%     %% &\phantom{{}={}} \ecase{\esplit{\eboxd y}}\\
%%     %% &\qquad (\inj i \eboxd x \caseto
%%     %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
%%     %%
%%     %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
%%     %% &\phantom{{}={}}\ecase{\esplit {\eboxd x}, \esplit {\eboxd\dx}}\\
%%     %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
%%     %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
%%     %% &\qquad (\inj i \eboxd x, \pwild
%%     %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
%%     %%
%%     \elet{\eboxd{x} = \phi e}\\
%%     &\phantom{{}={}} \esplit [\isocolor \ecase x\\
%%     &\phantom{= \esplit}\quad\isocolor
%%       (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
%%     &\phantom{= \esplit}\quad
%%       {\isocolor(\etuple{\inj i y, \pwild}
%%         \caseto \inj i \etuple{y, \dummy\<y})_i}]
%%     %%
%%     %% \ecase{\phi e}\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
%%     %% \caseto \inj i \eboxd{x,\dx})_i\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
%%     %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
%%     \\
%%     \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \todo{TODO: split cases for non-core syntax into separate figure.}

%%   \caption{Semi\naive{} term translation}
%% \end{figure*}


%% ----- Figure: Dummy function -----
\begin{figure*}
  \[\setlength\arraycolsep{.3em}\begin{array}{lcl}
    \dummy &:& A \to \D A\\
    \dummy \<(\pwild : \tbool) &=& \efalse\\
    \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
    \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
    \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
    \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
    %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
    \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
  \end{array}\]
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}


\clearpage
\appendix
\begin{center}\Large\scshape Proofs\end{center}

%\section{Proofs}

%% \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
%%   \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
%%   \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
%%   &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
%%   &&&\bot \bnfor e \vee f \bnfor \edown{e} \bnfor \ebigvee x e f\\
%%   &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
%%   &&& \prim{isEmpty}\<e \bnfor \esplit e \bnfor \prim{eq}\<e \bnfor \efix e
%% \end{array}\]

\newcommand\stareq{\overset{\boldsymbol\star}{=}}
\newcommand\daggereq{\overset{\dagger}{=}}
\newcommand\stardaggereq{\overset{\boldsymbol\star\dagger}{=}}

\thmForget*
\begin{proof}\label{proof:forget}

  We will make frequent and unremarked use of definitions from
  \cref{sec:changeposets}. First we induct on types to show $\vals{\incdens A} =
  \den A$. Equalities given by an inductive hypothesis are marked with a star,
  like so: $\stareq$.

  \begin{description}
    \item[Case $\isof A$:] \(\vals{\incdens{\isof A}}
      = \vals{\discof{\incdens A}}
      = \isof{\vals{\incdens A}} \stareq \isof{\den A}
      = \den{\isof A} \)

    %% \item[Case $\tset{\eqt A}$:]
    %%   \(\vals{\incdens{\tset{\eqt A}}} = \vals{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \stareq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tset{\eqt A}} \)

    \item[Case $\tset{\eqt A}$:]
      \(\vals{\incdens{\tset{\eqt A}}}
      = \vals{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \stareq \pfinof{\den{\eqt A}}
      = \den{\tset{\eqt A}} \)

      \todo{TODO: double-check against definitions in \cref{sec:CP-pfin}}

    \item[Case $\tunit$:] \(\vals{\incdens \tunit} = \vals\termO = \termO = \den{\tunit}\)

    \item[Case $A \x B$:] \(\vals{\incden{A \x B}}
      = \vals{(\incdens A \x \incdens B)}
      = \vals{\incdens A} \x \vals{\incdens B}
      \stareq \den{A} \x \den{B}
      = \den{A \x B} \)

    \item[Case $A + B$:] \(\vals{\incden{A + B}}
      = \vals{(\incdens A + \incdens B)}
      = \vals{\incdens A} + \vals{\incdens B}
      \stareq \den{A} + \den{B}
      = \den{A + B}
      \)

    \item[Case $A \to B$:] \(\vals{\incden{A \to B}}
      = \vals{(\expO{\incdens A}{\incdens B})}
      = \expO{\vals\incdens A}{\vals\incdens B}
      \stareq \expO{\den A}{\den B}
      = \den{A \to B}
      \)
  \end{description}

  \noindent
  Then we induct on typing derivations to show $\vals \incdens e = \den e$:

  \begin{description}
  \item[Case $x$] \XXX
  \item[Case $\dvar x$] \XXX
  \item[Case $\fnof x e$] \XXX
  \item[Case $e\<f$] \XXX
  \item[Case $\etuple{}$] \XXX
  \item[Case $\etuple{e,f}$] \XXX
  \item[Case $\pi_i\<e$] \XXX
  \item[Case $\inj i e$] \XXX
  \item[Case $(\ecase{e} (\inj i x \caseto f_i)_i)$] \XXX
  \item[Case $\eboxd e$] \XXX
  \item[Case $\elet{\eboxd x = e} f$] \XXX
  \item[Case $\bot$] \XXX

  \item[Case $e_1 \vee e_2$]
    \begin{align*}
      \vals{\incden{e_1 \vee e_2}}
      &= \vals{(\fork{\incdens{e_i}}_i \then \morph{join}_2)}
      && \text{by definition}\\
      &= \vals{\fork{\incdens{e_i}}_i} \then \vals{\morph{join}_2}
      && \text{functoriality of }\valfn\\
      &= \fork{\vals{\incdens{e_i}}}_i \then \morph{join}_2
      && \text{refinement along $\valfn$ (\cref{sec:CP-cartesian,sec:CP-families})}\\
      &= \fork{\den{e_i}}_i \then \morph{join}_2
      && \text{inductive hypothesis}\\
      &= \den{e_1 \vee e_2}
      && \text{by definition}
    \end{align*}

  \item[Case $\esetd{e_i}_i$] \XXX
  \item[Case $(\eford x e f)$] \XXX
  \item[Case $\eisEmpty e$] \XXX
  \item[Case $\esplit e$] \XXX
  \item[Case $\eeqd e f$] \XXX
  \item[Case $\efix e$] \XXX%
  \end{description}%
\end{proof}



\thmDeltaDen*
\begin{proof}
  \label{proof:delta-den}
  By induction on types. Again, $\stareq$ marks equalities given by an inductive
  hypothesis; additionally, $\daggereq$ indicates an appeal to
  \cref{thm:forget}.
  \begin{description}
    \item[Case $\isof A$:] \(\chgs{\incdens{\isof A}}
      = \chgs{\discof{\incdens A}}
      = \termO = \den{1} = \den{\D \isof A}\)

    %% \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
    %%   = \chgs{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \daggereq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tseteq A}
    %%   \)

    \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
      = \chgs{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \daggereq \pfinof{\den{\eqt A}}
      = \den{\tseteq A}
      \)

      \todo{TODO: double-check against definitions in \cref{sec:CP-pfin}}

    \item[Case $\tunit$:] \(\chgs{\incdens \tunit}
      = \chgs \termO = \termO = \den{\tunit} \)

    \item[Case $A \x B$:] \(\chgs{\incden{A \x B}}
      = \chgs{(\incdens A \x \incdens B)}
      = \chgs{\incdens A} \x \chgs{\incdens B}
      \stareq \den{\D A} \x \den{\D B}
      = \den{\D A \x \D B}
      = \den{\D(A \x B)} \)

    \item[Case $A + B$:] \(\chgs{\incden{A + B}}
      = \chgs{(\incdens A + \incdens B)}
      = \chgs{\incdens A} + \chgs{\incdens B}
      \stareq \den{\D A} + \den{\D B}
      = \den{\D A + \D B}
      = \den{\D(A + B)} \)

    \item[Case $A \to B$:]
      \begin{align*}
        \chgs{\incden{A \to B}}
        &= \chgs{(\expO{\incdens A}{\incdens B})}\\
        &= \expO {\isof{\vals{\incdens A}}} {
          \expO {\chgs{\incdens A}} {\chgs{\incdens B}}}
        & \text{by definition in \cref{sec:CP-exponentials}}
        \\
        &\stardaggereq \expO {\isof {\den A}} {\expO {\den{\D A}} {\den{\D B}}}\\
        &= \den{\isof A \to \D A \to \D B}\\
        &= \den{\D(A \to B)}
      \end{align*}
  \end{description}
\end{proof}


\thmTypeCorrect*
\begin{proof}\label{proof:typeCorrect}
  \XXX
\end{proof}

\end{document}
