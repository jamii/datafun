%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=18cm,width=38em,width=36.65625em,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=152mm,width=373pt,width=360pt,]{narrow}
%\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\geometry{bottom=36pt}\pagestyle{empty}

\documentclass{rntz}\usepackage{fantasy}%\geometry{textwidth=330pt,}
%\documentclass{rntz}\usepackage[tablet]{fantasy}\geometry{textwidth=330pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
\usepackage[skip=.5\baselineskip,labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.1}{rntzfont} % a4/b5, width=38em/373pt
%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4 width=36.66em/360pt
%\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy[laptop,tablet]
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}
%\usepackage[source,scaled=1.01,linespread=1.0132,linespread=1.015,]{rntzfont}
%\usepackage[librebaskerville,scaled=1.012,]{rntzfont} % zeu@Scale â‰ˆ .98

%% %% Nice for fantasy[phone].
%% \usepackage[sfdefault,scaled=.89060]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.04}\makeatother
%% \usepackage[cal=cm,bb=esstix,scaled=.93,bbscaled=.93]{mathalfa}
%% \renewcommand\mathit\textit\renewcommand\mathrm\text % argh
%% \usepackage[basic,defaultmathsizes]{mathastext}
%% \linespread{1.08}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}

\usepackage{notation}


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}

%% \noindent
%% % use a math environment to force loading math font.
%% ex/em: \the\fontdimen5\font{} / \the\fontdimen6\font \(\)\\
%% math ex: \the\fontdimen5\textfont1{} / \the\fontdimen6\textfont1\\
%% word space: \the\fontdimen2\font\\
%% baselineskip: \the\baselineskip\\
%% %% \par\begingroup\Large\noindent
%% %% x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} $f$f $t$t $o$o $T$T\emph{T} lIx\\
%% %% fb ff fh fi fj fk fl ft \emph{fb ff fh fi fj fk fl ft} Th \emph{Th}\\
%% %% ffb ffh ffi ffj ffk ffl fft \emph{ffb ffh ffi ffj ffk ffl fft}
%% %% \endgroup\\

\maketitle

\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (a \emph{Datafun model}; \cref{sec:datafun-models}). We
then define the category \CP{} of posets equipped with increasing changes, whose
morphisms are monotone maps equipped with \emph{derivatives} taking input
changes to output changes (\cref{sec:changeposets}). We construct two Datafun
models in \CP{}, an \emph{incremental} (\cref{sec:incremental}) and a
\emph{semi\naive} (\cref{sec:seminaive}), from which we read off our program
transformations. By construction, the incremental semantics extends the one in
\Poset{}. To prove the semi\naive{} transform correct, we construct a
type-indexed family of natural isomorphisms relating the incremental and
semi\naive{} semantics.

%% TODO: rewrite to match above strategy and add section links


%% ---- Syntax & typing rules ----
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
      \text{types} & A,B &\bnfeq& \tunit \bnfor A \x B \bnfor A + B
      \bnfor A \to B \bnfor \isof A \bnfor \tdown{\eqt A}
      \\
      \text{semilattices} & L,M &\bnfeq&
      \tunit \bnfor L \x M \bnfor A \to L \bnfor \tdown{\eqt A}
      \\
      \text{eqtypes} & \eqt A, \eqt B &\bnfeq& \tunit \bnfor \eqt A \x \eqt B
      \bnfor \eqt A + \eqt B \bnfor \isof{\eqt A} \bnfor \tdown{\eqt A}
      \\[.5em]
      \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
      \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
      &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
      &&&\bot \bnfor e \vee f \bnfor \edown{e} \bnfor \ebigvee x e f\\
      &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
      &&& \prim{isEmpty}\<e \bnfor \esplit e \bnfor \prim{eq}\<e \bnfor \efix e
      \\[.5em]
      \text{contexts} & \G &\bnfeq& (H_i)_i\\
      \text{hypotheses} & H &\bnfeq& \h x A \bnfor \hd x A
    \end{array}
    \\
    \stripcxd\G = (\hd x A)_{\hd x A \in \G}
    \\
    \infer{\h x A \in \G}{\J x \G A}

    \infer{\hd x A \in \G}{\J {\dvar x} \G A}

    \infer{\J e {\G,\h x A} B}{\J {\fnof x e} \G {A \to B}}

    \infer{\J e \G {A \to B} \\ \J f \G A}{\J {e\<f} \G B}

    \infer{\quad}{\J {\etuple{}} \G \tunit}

    \infer{(\J{e_i}\G{A_i})_i}{\J{\etuple{e_1,e_2}} \G {A_1 \x A_2}}

    \infer{\J e \G {A_1 \x A_2}}{\J{\pi_i\<e}\G{A_i}}

    \infer{\J e \G A_i}{\J{\inj i e}\G{A_1 + A_2}}

    \infer{\J e \G {A_1 + A_2} \\
      (\J {f_i} {\G,\h {x_i} {A_i}} {B})_i
    }{
      \J {\ecase{e} (\inj i {x_i} \caseto f_i)_i} \G B
    }

    \infer{\quad}{\J\bot\G L}

    \infer{(\J{e_i}\G L)_i}{\J{e_1 \vee e_2}\G L}

    \infer{\J e \G {\eqt A}}{\J {\edown e} \G {\tdown {\eqt A}}}

    \infer{\J e \G {\tdown {\eqt A}} \\
      \J f {\G,\h x {\eqt A}} L
    }{\J {\ebigvee x e f} \G L}

    \infer{\J {\isocolor e} {\stripcxd\G} A}{\J{\eboxd e} \G {\isof A}}

    \infer{\J e \G {\isof A} \\ \J f {\G,\hd x A} B}{
      \J {\elet{\eboxd x = e} f} \G B}

    \infer{\J e \G {\isof{\tdown\tunit}}}{\J {\prim{isEmpty}\<e} \G {\tunit + \tunit}}

    \infer{\J e \G {\isof{(A + B)}}}{\J{\esplit e} \G {\isof A + \isof B}}

    \infer{\J e \G {\isof{(\eqt A \x \eqt A)}}}{\J{\prim{eq}\<e} \G {\tdown\tunit}}

    \infer{\J e \G {\isof{(\eqt L \to \eqt L)}}}{\J{\prim{fix}\< e} \G {\eqt L}}
  \end{mathpar}

  \caption{Datafun core syntax and typing rules}
  \label{fig:core-datafun}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& ... \bnfor \tbool \bnfor \tset{\eqt A}
    \\
    \text{terms} & e,f,g &\bnfeq&
    ... \bnfor \esetd{e_i}_i \bnfor \eeqd{e}{f} \bnfor \eford{x}{e} f\\
    &&& \efalse \bnfor \etrue \bnfor \eif e f g \bnfor \ewhen e f\\
    &&& \edcase{e} (\inj i {\dvar{x_i}} \caseto f_i)_{i\in\{1,2\}} \bnfor \efixisd x e
  \end{array}\]

  \begin{mathpar}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} A)_i}{
      \J {\esetd{e_i}_i} \G {\tset{A}}}

    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}
          {\J {\eeqd{e_1}{e_2}} \G \tbool}

    \infer{
      \J e \G {\tset A} \\
      \J f {\G,\hd x A} L
    }{\J {\eford x e f} \G L}

    \infer{\quad}{\J \etrue \G \tbool}

    \infer{\quad}{\J \efalse \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} \tbool \\ (\J{f_i}\G B)_i}
          {\J {\eifd e{f_1}{f_2}} \G {B}}

    \infer{\J e \G \tbool \\ \J f \G L}{\J {\ewhen e f} \G L}

    \infer{\J {\isocolor e} {\stripcxd{\G}, \h x {\eqt L}} {\eqt L}}
          {\J {\efixisd x e} \G {\eqt L}}
  \end{mathpar}

  \caption{Surface syntax and typing rules}
  \label{fig:surface-syntax}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \tbool &\desugars \tdown{\tunit} &
    \tset{\eqt A} &\desugars \tdown{\isof {\eqt A}}
    \\[.5em]
    \efalse &\desugars \bot &
    \etrue &\desugars \edown{\etuple{}}
    \\
    \eeqd e f &\desugars \prim{eq}\< \eboxd{\etuple{e, f}} &
    \ewhen e f &\desugars \ebigvee {\freshvar\pwild} e f
  \end{align*}

  \begin{align*}
    \esetd{e_i}_i &\desugars \edown\eboxd{e_0} \vee ... \vee \edown\eboxd{e_n}
    \quad \text{(or $\bot$ if $n=0$)}\\
    \eford x e f &\desugars \ebigvee {\freshvar y} e {\elet{\eboxd x = \freshvar y} f}\\
    \eif e {f_1}{f_2} &\desugars
    \ecase{\prim{isEmpty}\<e} (\inj i {\freshvar\pwild} \caseto f_i)_i\\
    \edcase e (\inj i {\dvar{x_i}} \caseto f_i)_i
    &\desugars \ecase{\esplit \eboxd e}
    (\inj i {\freshvar y} \caseto \elet{\eboxd{x_i} = \freshvar y} f_i)_i\\
    \efixisd x e &\desugars \efix \eboxd{\fnof {\color{black} x} e}
  \end{align*}

  \vspace{-.5ex}
  {\small Fresh variables ($\freshvar y$, $\freshvar\pwild$) are marked in \freshvar{pink}.}

  \vspace{.5ex}
  %% TODO: consider the pattern-matching desugaring in "Some pattern-matching
  %% elaboration rules". if we have that, we probably don't also need \edcase.
  %% Only include one in final paper.
  \caption{Desugaring of surface syntax}
  \label{fig:desugaring}
\end{figure*}

%% TODO: do we need all of these?
\begin{figure*}
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\desugars& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
    \\[.33em]
    \ecase{e} x \caseto f;\ (p_i \caseto g_i)_i
    &\desugars& \elet{x = e} f
    \\[.33em]
    \ecase{e} \eboxd x \caseto f;\ (p_i \caseto g_i)_i
    &\desugars& \elet{\eboxd x = e} f
    \\[.33em]
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\desugars& \elet{x = e}\\
    && \ecase{\pi_1\< x,\, \pi_2\< x} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\desugars& \elet{\eboxd x = e}\\
    && \ecase{\eboxd{\pi_1\<x}, \eboxd{\pi_2\<x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\desugars& \ecase{e} (\inj i x \caseto \ecase{x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\desugars& \ecase{\esplit e} (\inj i \eboxd{p_i} \caseto f_i)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
\end{figure*}


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:
  \[\setlength\arraycolsep{.33em}
  \begin{array}{rcl}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{array}\]
\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive maps
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``free semilattice''} functor \(\down : \catC \to \catC\) equipped
  with maps
  \begin{align*}
    \morph{singleton}_A &: A \to \downof{A}\\
    \morph{isEmpty} &: \discof{\downof{\termO}} \to \termO + \termO\\
    \morph{strong}_{A,B} &: A \x \downof{B} \to \downof{(A \x B)}
  \end{align*}

\item \emph{Equality}, \emph{semilattice}, and \emph{fixed point
  objects}, which must interpret equality, semilattice, and fixed point types
  respectively. An object $A$ is:
  %
  \begin{itemize}
  \item An equality object if equipped with a morphism $\morph{eq} : \discof A
    \x \discof A \to \downof \termO$.

  \item A semilattice object if equipped with an \down-algebra $\morph{collect} :
    \downof{A} \to A$ and a family of morphisms $\morph{join}_n : A^n \to A$.

  \item A fixed point object if equipped with a morphism $\morph{fix} :
    \discof{(\expO A A)} \to A$.
  \end{itemize}

\end{enumerate}

\noindent
\Cref{fig:general-semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \down{} be the free semilattice monad (i.e.
finitely-generated downward-closed sets).

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


%% \subsection{Object families}
%% \label{sec:object-families}

%% To be a Datafun model, semilattice types must be interpreted into
%% \emph{semilattice objects}; equality types must be interpreted into
%% \emph{equality objects}; and fixed point types must be interpreted into
%% \emph{fixed point objects}. A given object $A$ is:

%% \begin{itemize}
%% \item A semilattice object when equipped with an \down-algebra $\morph{collect} :
%%   \downof{A} \to A$ and a family of morphisms $\morph{join}_n : A^n \to A$.

%% \item An equality object when equipped with a morphism $\morph{eq} : \discof A \x
%% \discof A \to \downof \termO$.

%% \item A fixed point object when equipped with a morphism $\morph{fix} :
%% \discof{(\expO A A)} \to A$.
%% \end{itemize}


%% ---- Semantics in a Datafun Model ----
\begin{figure*}
  \emph{Types and contexts}\vspace{-.5ex}

  \begin{align*}
    \den{\tunit} &= \termO & \den{A \to B} &= \expO{\den{A}}{\den{B}}
    \\
    \den{\tdown A} &= \downof{\den{A}} & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{\G} &= \prod_{H \in \G} \den{H} &
    \den{\h x A} &= \den{A} & \den{\hd x A} &= \discof{\den{A}}
  \end{align*}

  \vspace{1ex}\emph{Terms}\vspace{-.5ex}

  \begin{align*}
    \den{\dvar x} &= \pi_{\dvar x} \then \varepsilon \quad \text{($\dvar x$ discrete)}
    & \den{x} &= \pi_x \quad \text{($x$ monotone)}
    \\
    \den{\fnof x e} &= \lambda\den{e}
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e_i}_i} &= \fork{\den{e_i}}_i
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \den{\inj i e} &= \den{e} \then \injc_i
    &
    \den{\bot} &= \termI \then \morph{join}_0
    \\
    \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}_2
    &
    \den{\edown e} &= \den{e} \then \morph{singleton}
    \\
    \bigden{\eboxd e} &= \morph{strip} \then \discof{\den e}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\id, \den{e}} \then \den{f}
    \\
    \den{\prim{isEmpty}\<e} &= \den{e} \then \morph{isEmpty}
    & \den{\esplit e} &= \den{e}\then \discosum
    \\
    \den{\prim{eq}\<e} &= \den{e} \then \morph{eq}
    & \den{\efix e} &= \den{e} \then \morph{fix}
  \end{align*}

  \begin{align*}
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\id, \den{e}} \then \morph{dist}^\x_+ \then \bigkrof{\den{f_i}}_i
    %\bigkrof{\den{f_i}}_i \circ \morph{dist}^\x_+ \circ \fork{\id, \den{e}}
    \\
    \den{\ebigvee x e f} &=
    \fork{\id,\den{e}} \then \morph{strong} \then \downof{\den{f}} \then \morph{collect}
    %\morph{collect} \circ \downof{\den{f}} \circ \morph{strong} \circ \fork{\id,\den{e}}
  \end{align*}

  \vspace{1ex}\emph{Lemmas}\vspace{-.5ex}

  \begin{align*}
    \morph{dist}^\x_+ &: A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)\\
    % this could be simpler if it distributed in the opposite direction.
    \morph{dist}^\x_+ &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    \\[1ex]
    \morph{strip} &: \den\G \to \discof{\den{\stripcxd\G}}\\
    \morph{strip} &= \fork{\pi_{\dvar x} \then \delta}_{\hd x A \in \G} \then \discox
  \end{align*}

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \down}$}
  \label{fig:general-semantics}
\end{figure*}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations inv\-olv\-ing \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent In particular, for every $x$ there is a (not necessarily unique)
\emph{zero change}, $\zero_x$, such that $x \upd \zero_x = x$.\footnote{Use of
  the $\zero_x$ operator amounts to invoking the axiom of choice.}

Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\nopagebreak
\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

%% % Doesn't work on narrow paper, eg. a5.
%% \nopagebreak
%% \[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}
%% \quad\text{or equivalently}\quad
%% f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


%\subsection{Zero changes and change composition}

%% Applying the axiom of choice to soundness \& completeness for increases, we
%% recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
%% (\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
%% identity and associativity laws of a category, but $\zero$ will be useful
%% nonetheless. We will see how to duck this non-constructive use of the axiom of
%% choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\oplus$ and showing the
existence of derivatives.


\subsection{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value-level structure is inherited from \Poset{} along \valfn{}. The
  change-poset structure is also inherited from \Poset{}, while the projection
  and injection's derivatives operate pointwise on changes:

  \begin{align}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \label{eqn:delta-distributes-over-sums-and-products}
    \\
    \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
  \end{align}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
    \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

  \begin{gather*}
    \fork{f_i}_i \<(x \upd \dx)
    = (f_i(x \upd \dx))_i
    = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
    = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
  \end{gather*}

  \noindent
  A derivative for split must obey \[ \krof{f_i}_i\<(\inj i x \upd \inj i \dx)
  = f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx) \] so one
  valid choice is

  \[\deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
  \]

  \noindent
  The second case is dead code; any value of the right type would do. We will
  exploit this in \cref{sec:incremental} to avoid needing the axiom of choice
  (used to define $\zero_x$) in the context of Datafun.
\end{proof}


\subsection{Exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have
%
\[ (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \]
%
and more generally, \cref{eqn:function-update} can be rewritten:
%
\begin{equation*}
  f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx)
\end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Î“ x A -> B
%% Exists Î»f : Î“ -> (A => B)
%% such that f = (Î»f Ã— id); eval

% WTS: f â‰¤ g â‡” âˆƒdf. f -df-> g

% Suppose f â‰¤ g.
% WTS: âˆƒdf. f --df--> g.
% Let's calculate! df has to be such that
% âˆ€(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


\subsection{The lifted \iso{} comonad and its relatives}
%% TODO: maybe call this \iso_{\boldsymbol\Delta} instead?

\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map. Since $\isof A$ is ordered discretely,
values \emph{cannot} increase. So the simplest definition, and the one we will
use, is:

\begin{align*}
  \chgs{\isof A} &= \termO
  &
  x \oplus_{\isof A} \tuple{} = x
\end{align*}

\noindent
Functoriality, extraction, duplication, and product- and sum-distribution all
refine the corresponding properties of $\iso_\Poset$, and their derivatives are
fairly straightforward:
%
\begin{mathpar}
  \deriv{\iso(f)} \<x \<\tuple{} = \tuple{}

  \deriv\delta_A \<x \<\tuple{} = \tuple{}

  \deriv\varepsilon_A \<x \<\tuple{} = \zero_x
  \\
  \deriv{{\discox}} \<x \<\dx = \tuple{}

  \deriv{{\discosum}} \<(\inj i x) \<\tuple{} = \inj i {\tuple{}}
\end{mathpar}

\noindent
\todo{TODO: since distribution over products \& sums isn't equality, what does
  this mean for our actual \emph{implementation}? seems like $\delta(\esplit e)$
  might have to actually do some work!}

\newcommand\altiso{\iso_{\textrm{alt}}}

\subsubsection{The alternative $\altiso$}

There is another refinement of $\iso$ in \CP{}, which I'll call $\altiso$ for
clarity, defined like so:

\begin{align*}
  \chgs{\altiso A} &= \altiso \chgs A
  &
  x \oplus_{\altiso A} \dx = y &\iff x = y \wedge x \oplus_A \dx = y
\end{align*}

\noindent
So $\altiso A$ inherits all of $A$'s changes, but ordered discretely and with
\emph{only zero-changes still valid}. The derivatives of functoriality,
duplication, and extraction are different:
%
\begin{mathpar}
  \deriv{\altiso(f)} = \deriv f

  \deriv\delta_A \<x\<\dx = \dx

  \deriv\varepsilon_A \<x\<\dx = \dx
\end{mathpar}

\noindent
Product- and sum-distribution are actually identity maps, because (although it
takes a little checking to establish) $\prod_i \altiso A_i = \altiso \prod_i A$
and $\sum_i \altiso A_i = \altiso \sum_i A_i$.

$\altiso$ avoids the need to use the non-constructive (and not obviously
computable) $\zero_x$ to define the comonad extraction $\varepsilon$. However,
for us this will turn out not to be an issue. \todo{TODO: explain why $\chgs
  \isof A = \termO$ turns out to be handy - it allows us to split up $\Phi$ and
  $\Delta$ on types.}


\subsection{The lifted $\down$ monad}
\XXX


\subsection{Semilattice, equality, and fixed-point structure}
\XXX


\section{Incrementalization}
\label{sec:incremental}

The \emph{incremental semantics} for Datafun, notated $\incden{-}$, is given by
the Datafun model in \CP{} constructed in \cref{sec:changeposets}, letting
$\disco = \iso_\CP$ and $\down = \down_\CP$. As we took care to show while
constructing it, this \emph{refines} the standard model along the forgetful
functor $\valfn$, that is:

\begin{theorem}
  \(\vals{\incden{-}} = \den{-}_\Poset\).
\end{theorem}
\begin{proof}
  By induction on types and typing derivations. For example,

%% TODO: check this proof!
\begin{align*}
  \vals{\incden{e_1 \vee e_2}}
  &= \vals{(\fork{\incden{e_i}}_i \then \morph{join}_2)}
  && \text{by definition}\\
  &= \vals{\fork{\incden{e_i}}_i} \then \vals{\morph{join}_2}
  && \text{functoriality of }\valfn\\
  &= \fork{\vals{\incden{e_i}}}_i \then \morph{join}_2
  && \text{refinement along \valfn{} (\cref{sec:refines})}\\
  &= \fork{\den{e_i}_\Poset}_i \then \morph{join}_2
  && \text{inductive hypothesis}\\
  &= \den{e_1 \vee e_2}_\Poset
  && \text{by definition}
\end{align*}
\end{proof}


%% ---- More figures ----
%% \begin{figure*}
%%   \begin{align*}
%%     \delta x &= \dx\\
%%     \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
%%     \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
%%     \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
%%     \delta (\pi_i\<e) &= \pi_i\< \delta e\\
%%     \delta (\inj i e) &= \inj i {\delta e}\\
%%     \delta \bot &= \bot &
%%     \delta (e \vee f) &= \delta e \vee \delta f\\
%%     \delta \etrue = \delta \efalse &= \efalse
%%     & \delta\esetd{e_i}_i &= \eset{}\\
%%     \delta \eboxd{e} &= \eboxd{\delta e}
%%     & \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \begin{align*}
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
%%     \\
%%     \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
%%     \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
%%     \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
%%     \delta (\eford x e f)
%%     &= (\eford x {\delta e} f)\\
%%     &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
%%     \delta (\ecase e (\inj i x \caseto f_i)_i)
%%     %% &= \ecase{\esplit{\eboxd e}}\\
%%     %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
%%     &= \ecase{\esplit{\eboxd e},\, \delta e}\\
%%     &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
%%     &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
%%     %\elet{\dx = \dummy\<x}
%%     \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
%%   \end{align*}
%%   \caption{The derivative translation}
%%   \label{fig:derivatives}
%% \end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\todo{TODO: explain faster-fix?}

\todo{TODO: explain semi\naive{} semantics --- it's the same except we interpret
  $\iso$ as $\blackiso$ and fix as fast-fix. Read off the semi\naive{}
  transform.}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}

\begin{figure*}
  \begin{align*}
    \Phi \tunit &= \tunit & \D\tunit &= \tunit\\
    \Phi \tdown{\eqt A} &= \tdown{\Phi \eqt A} & \D\tdown{\eqt A} &= \tdown{\Phi \eqt A}\\
    \Phi \isof A &= \isof{(\Phi A \x \D A)}
    & \D\isof A &= \isof \D A\\
    \Phi(A \to B) &= \Phi A \to \Phi B
    & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
    \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
    \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
    %% % Syntax sugar cases.
    %% \\
    %% \Phi \tbool &= \tbool & \D\tbool &= \tbool\\
    %% \Phi \tset{A} &= \tset{\Phi A} & \D\tset{A} &= \tset{\Phi A}
  \end{align*}
  \caption{Semi\naive{} type translation}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.3em}\begin{array}{lcl}
    \dummy &:& A \to \D A\\
    \dummy \<(\pwild : \tbool) &=& \efalse\\
    \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
    \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
    \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
    \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
    %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
    \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
  \end{array}\]
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}


%% ---- Seminaive ("go faster") term translation ----
\begin{figure*}

  %% TODO: think about this translation and syntax sugar. for example, the
  %% case-split I use in \phi(\esplit e) is only valid *because* \esplit exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

  \begin{align*}
    %% Ugh, I should really mark that some of these variables are monotone and
    %% others discrete in some non-color way.
    \phi x &= x & \delta x &= \dx\\
    \phi \dvar x &= \dvar x & \delta \dvar x &= \dvar\dx\\
    \phi(\fnof x e) &= \fnof x \phi e
    & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
    \phi(e\<f) &= \phi e\<\phi f
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \phi\etuple{e_i}_i &= \etuple{\phi e_i}_i
    & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
    \phi(\pi_i\<e) &= \pi_i\<\phi e
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \phi(\inj i e) &= \inj i \phi e
    & \delta(\inj i e) &= \inj i \delta e\\
    \phi\bot &= \bot & \delta\bot &= \bot\\
    \phi(e \vee f) &= \phi e \vee \phi f
    & \delta(e \vee f) &= \delta e \vee \delta f\\
    \phi(\edown e) &= \edown \phi e & \delta(\edown e) &= \bot\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    & \delta\eboxd{e} &= \eboxd{\delta e}\\
    %% ugh
    \phi(\prim{eq}\<e) &= \elet{\eboxd{x,\pwild} = \phi e} \prim{eq}\<\dvar x
    & \delta(\prim{eq}\<e) &= \bot\\
    \phi(\prim{fix}\<e) &= \prim{fast-fix}\<\phi e
    & \delta(\prim{fix}\<e) &= \bot
  \end{align*}

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\esplit{\eboxd{\color{Rhodamine} \phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    \phi\bigl(\ebigvee x e f\bigr)
    &= \ebigvee x {\phi e} {\phi f}
    \\
    %% wait, is weakening being used here?
    \delta\bigl(\ebigvee x e f\bigr)
    &= \bigl(\ebigvee x {\delta e} {\color{Rhodamine}\phi f}\bigr) \vee
    \bigl(\ebigvee x {{\color{Rhodamine}\phi e} \vee \delta e} {\delta f}\bigr)
%%     \delta(\eford x e f)
%%     &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
%%     &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\delta f}{\dx \substo \zero\<x})
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \color{Rhodamine}\phi e} \delta f
    \\
    \phi(\prim{isEmpty}\<e) &=
    %% ugh.
    \elet{\eboxd{\etuple{x,\pwild}} = \phi e} \prim{isEmpty}\<\dvar x\\
    %% TODO: check this lines up with \delta(if then else), because that's where
    %% it comes up.
    \delta(\prim{isEmpty}\<e) &= \XXX\\
    \phi(\esplit e) &= \elet{\eboxd{x} = \phi e}\\
    &\phantom{{}={}} \esplit [\isocolor \ecase x\\
    &\phantom{= \esplit}\quad\isocolor
      (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    &\phantom{= \esplit}\quad
      {\isocolor(\etuple{\inj i y, \pwild}
        \caseto \inj i \etuple{y, \dummy\<y})_i}]
    \\
    \delta(\esplit e) &= \esplit \delta e
  \end{align*}

  \caption{Semi\naive{} term translation}
\end{figure*}

%% ---- old seminaive term translation ----
%% \begin{figure*}
%%   \begin{align*}
%%     \phi x &= x & \delta x &= \dx\\
%%     \phi(\fnof x e) &= \fnof x \phi e
%%     & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
%%     \phi(e\<f) &= \phi e\<\phi f
%%     & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
%%     \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
%%     & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
%%     \phi(\pi_i\<e) &= \pi_i\<\phi e
%%     & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
%%     \phi(\inj i e) &= \inj i \phi e
%%     & \delta(\inj i e) &= \inj i \delta e\\
%%     \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
%%     \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
%%     \phi\bot &= \bot & \delta\bot &= \bot\\
%%     \phi(e \vee f) &= \phi e \vee \phi f
%%     & \delta(e \vee f) &= \delta e \vee \delta f\\
%%     \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
%%     \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
%%     & \delta\eboxd{e} &= \eboxd{\delta e}
%%   \end{align*}

%%   %% TODO: determine exactly how much syntax sugar I want to allow in the target
%%   %% of this translation. for example, the case-split I use in \phi(\esplit e)
%%   %% is only valid *because* \esplit exists.
%%   %%
%%   %% Would be nice to give the syntax sugar explicitly, but maybe more effor
%%   %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

%%   %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
%%   %% TODO FIXME: \phi(if then else), \delta(if then else)!

%%   \begin{align*}
%%     \phi(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
%%     \\
%%     \delta(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\esplit{\eboxd{\phi e}},\, \delta e}\\
%%     &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad ({\inj i {\eboxd x},\, \pwild}
%%       \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
%%     %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
%%     %% &\qquad (\inj i \eboxd x
%%     %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
%%     %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
%%     %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
%%     \\
%%     \phi(\eford x e f)
%%     &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\phi f}{\dx \substo \zero\<x}
%%     \\
%%     \delta(\eford x e f)
%%     &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
%%     &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\delta f}{\dx \substo \zero\<x})
%%     \\
%%     \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
%%     \\
%%     \delta(\ewhen e f)
%%     &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
%%     \\
%%     \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
%%     \\
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
%%     \\
%%     \phi(\esplit e) &=
%%     %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
%%     %% &\phantom{{}={}} \ecase{\esplit{\eboxd y}}\\
%%     %% &\qquad (\inj i \eboxd x \caseto
%%     %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
%%     %%
%%     %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
%%     %% &\phantom{{}={}}\ecase{\esplit {\eboxd x}, \esplit {\eboxd\dx}}\\
%%     %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
%%     %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
%%     %% &\qquad (\inj i \eboxd x, \pwild
%%     %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
%%     %%
%%     \elet{\eboxd{x} = \phi e}\\
%%     &\phantom{{}={}} \esplit [\isocolor \ecase x\\
%%     &\phantom{= \esplit}\quad\isocolor
%%       (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
%%     &\phantom{= \esplit}\quad
%%       {\isocolor(\etuple{\inj i y, \pwild}
%%         \caseto \inj i \etuple{y, \dummy\<y})_i}]
%%     %%
%%     %% \ecase{\phi e}\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
%%     %% \caseto \inj i \eboxd{x,\dx})_i\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
%%     %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
%%     \\
%%     \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \todo{TODO: split cases for non-core syntax into separate figure.}

%%   \caption{Semi\naive{} term translation}
%% \end{figure*}


\subsection{The \blackiso{} comonad}

\todo{TODO: explain $\blackiso$. show it's naturally isomorphic to $\iso$.}

\end{document}
